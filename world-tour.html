<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming Events World Tour</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3e 50%, #0c0c1e 100%);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .header-stats {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
        }

        .travelers-count {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #667eea);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 4s ease infinite;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .travelers-label {
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-top: 5px;
        }

        .current-location {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .location-flag {
            font-size: 40px;
            margin-bottom: 8px;
        }

        .location-city {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .location-event {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 12px;
        }

        .location-unlock {
            font-size: 13px;
            color: #f093fb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .progress-container {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.6;
        }

        .cities-legend {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .legend-title {
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 13px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .legend-item.unlocked { opacity: 1; }
        .legend-item.current { opacity: 1; color: #f093fb; }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }

        .legend-item.unlocked .legend-dot {
            background: #4facfe;
            box-shadow: 0 0 10px #4facfe;
        }

        .legend-item.current .legend-dot {
            background: #f093fb;
            box-shadow: 0 0 10px #f093fb;
            animation: pulse-dot 1s ease infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            .cities-legend { display: none; }
            .travelers-count { font-size: 36px; }
            .travelers-label { font-size: 12px; letter-spacing: 2px; }
            
            .current-location {
                padding: 12px 20px;
                width: 90%;
                max-width: 320px;
                bottom: 20px;
                border-radius: 16px;
            }
            .location-flag { font-size: 28px; margin-bottom: 4px; }
            .location-city { font-size: 18px; }
            .location-event { font-size: 12px; margin-bottom: 8px; }
            .location-unlock { font-size: 11px; }
            
            .progress-container {
                width: 90%;
                bottom: 120px;
            }
            .progress-labels { font-size: 10px; }
            
            .instructions { display: none; }
        }

        @media (max-width: 480px) {
            .travelers-count { font-size: 28px; }
            .travelers-label { font-size: 10px; letter-spacing: 1px; }
            
            .current-location {
                padding: 10px 15px;
                bottom: 15px;
            }
            .location-flag { font-size: 24px; }
            .location-city { font-size: 16px; }
            .location-event { font-size: 11px; }
            .location-unlock { font-size: 10px; gap: 4px; }
            
            .progress-container {
                bottom: 100px;
            }
            .progress-bar { height: 6px; }
            .progress-labels { font-size: 9px; }
        }

        @media (max-height: 600px) {
            .current-location {
                padding: 8px 15px;
                bottom: 10px;
            }
            .location-flag { font-size: 20px; margin-bottom: 2px; }
            .location-city { font-size: 14px; margin-bottom: 2px; }
            .location-event { font-size: 10px; margin-bottom: 6px; }
            .location-unlock { font-size: 10px; }
            
            .progress-container { bottom: 85px; }
            .header-stats { top: 10px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="ui-overlay">
        <div class="header-stats">
            <div class="travelers-count" id="visitorCount">0</div>
            <div class="travelers-label">üåç World Travelers</div>
        </div>

        <div class="instructions">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom</div>

        <div class="cities-legend">
            <div class="legend-title">üó∫Ô∏è World Tour</div>
            <div id="legendItems"></div>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-labels">
                <span id="progressCurrent">Paris</span>
                <span id="progressNext">Next: Cologne</span>
            </div>
        </div>

        <div class="current-location">
            <div class="location-flag" id="locationFlag">üá´üá∑</div>
            <div class="location-city" id="locationCity">Paris</div>
            <div class="location-event" id="locationEvent">Paris Games Week</div>
            <div class="location-unlock" id="locationUnlock">
                <span>üéÆ</span>
                <span>L'aventure commence !</span>
            </div>
        </div>
    </div>

    <!-- Three.js + GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // ============================================================
        // CONFIGURATION - MODIFIE CES CHEMINS SELON TES FICHIERS
        // ============================================================
        const CONFIG = {
            // Texture de la Terre (mettre le chemin vers ton fichier)
            earthTexture: 'rss/earth_texture.jpg',
            
            // Mod√®le 3D du personnage (mettre le chemin vers ton fichier GLB)
            characterModel: 'models/character.glb',
            
            // Taille du personnage (ajuste selon ton mod√®le)
            characterScale: 0.05,
            
            // Rotation initiale du personnage (en radians)
            characterRotation: { x: 0, y: 0, z: 0 }
        };
        // ============================================================

        // ============ CITIES DATA ============
        const cities = [
            { name: "Paris", flag: "üá´üá∑", event: "Paris Games Week", unlock: "L'aventure commence !", lat: 48.8566, lng: 2.3522, threshold: 0, color: 0x667eea },
            { name: "Cologne", flag: "üá©üá™", event: "Gamescom", unlock: "üé´ Premier event d√©bloqu√© !", lat: 50.9375, lng: 6.9603, threshold: 100, color: 0xffcc00 },
            { name: "London", flag: "üá¨üáß", event: "PG Connects London", unlock: "üó∫Ô∏è New territory unlocked !", lat: 51.5074, lng: -0.1278, threshold: 300, color: 0xff6b6b },
            { name: "San Francisco", flag: "üá∫üá∏", event: "GDC", unlock: "üé¨ Dev zone reached !", lat: 37.7749, lng: -122.4194, threshold: 600, color: 0x4facfe },
            { name: "Los Angeles", flag: "üá∫üá∏", event: "Summer Game Fest", unlock: "‚≠ê Hollywood level !", lat: 34.0522, lng: -118.2437, threshold: 1000, color: 0xf093fb },
            { name: "Tokyo", flag: "üáØüáµ", event: "Tokyo Game Show", unlock: "üèÜ Legendary destination !", lat: 35.6762, lng: 139.6503, threshold: 2000, color: 0xff4757 },
            { name: "Bali", flag: "üáÆüá©", event: "IGDX", unlock: "üèùÔ∏è Hidden gem found !", lat: -8.3405, lng: 115.0920, threshold: 3500, color: 0x2ed573 },
            { name: "Worldwide", flag: "üåç", event: "Global Domination", unlock: "üöÄ You've conquered the world !", lat: 0, lng: 0, threshold: 5000, color: 0xffd700 }
        ];

        // ============ THREE.JS VARIABLES ============
        let scene, camera, renderer, globeGroup;
        let cityMarkers = [];
        let character;
        let mixer; // Pour les animations du mod√®le
        let targetRotation = { x: 0.3, y: 0 };
        let currentRotation = { x: 0.3, y: 0 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let visitorCount = 0;
        let currentCityIndex = 0;
        let time = 0;
        let clock = new THREE.Clock();

        // ============ INIT ============
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            createGlobe();
            createCityMarkers();
            createRoute();
            loadCharacterModel();
            createStars();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x4facfe, 0.4);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onMouseUp);

            initCounter();
            animate();
        }

        // ============ GLOBE AVEC TEXTURE ============
        function createGlobe() {
            const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
            const textureLoader = new THREE.TextureLoader();
            
            // Charger la texture
            textureLoader.load(
                CONFIG.earthTexture,
                // Succ√®s : texture charg√©e
                function(texture) {
                    console.log('‚úÖ Texture Terre charg√©e !');
                    const globeMaterial = new THREE.MeshPhongMaterial({
                        map: texture,
                        bumpMap: texture,
                        bumpScale: 0.02,
                        specular: new THREE.Color(0x333333),
                        shininess: 5
                    });
                    const globe = new THREE.Mesh(globeGeometry, globeMaterial);
                    globe.name = 'earth';
                    globeGroup.add(globe);
                },
                // Progression
                undefined,
                // Erreur : utiliser le fallback
                function(error) {
                    console.log('‚ö†Ô∏è Texture non trouv√©e, utilisation du style par d√©faut');
                    createFallbackGlobe(globeGeometry);
                }
            );

            // Wireframe grid
            const wireGeometry = new THREE.SphereGeometry(1.005, 36, 18);
            const wireMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                wireframe: true,
                transparent: true,
                opacity: 0.08
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            globeGroup.add(wireframe);

            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(1.12, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                transparent: true,
                opacity: 0.12,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            globeGroup.add(atmosphere);
        }

        // Globe de secours si pas de texture
        function createFallbackGlobe(geometry) {
            const globeMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a4a7a,
                emissive: 0x0a1a2a,
                emissiveIntensity: 0.3,
                shininess: 10
            });
            const globe = new THREE.Mesh(geometry, globeMaterial);
            globe.name = 'earth';
            globeGroup.add(globe);
            
            // Ajouter des continents simplifi√©s
            createFallbackContinents();
        }

        function createFallbackContinents() {
            const continentData = [
                { lat: 50, lng: 10, scale: 0.15 },
                { lat: 45, lng: 0, scale: 0.12 },
                { lat: 55, lng: 20, scale: 0.1 },
                { lat: 35, lng: 100, scale: 0.25 },
                { lat: 50, lng: 80, scale: 0.2 },
                { lat: 25, lng: 120, scale: 0.15 },
                { lat: 40, lng: 140, scale: 0.1 },
                { lat: 45, lng: -100, scale: 0.22 },
                { lat: 35, lng: -90, scale: 0.18 },
                { lat: 55, lng: -110, scale: 0.15 },
                { lat: -15, lng: -60, scale: 0.18 },
                { lat: -30, lng: -65, scale: 0.12 },
                { lat: 10, lng: 20, scale: 0.2 },
                { lat: -10, lng: 25, scale: 0.15 },
                { lat: 25, lng: 30, scale: 0.1 },
                { lat: -25, lng: 135, scale: 0.14 },
                { lat: -5, lng: 115, scale: 0.1 },
            ];

            const landMaterial = new THREE.MeshPhongMaterial({
                color: 0x2d5a3d,
                emissive: 0x1a3320,
                emissiveIntensity: 0.2
            });

            continentData.forEach(function(continent) {
                const pos = latLngToVector3(continent.lat, continent.lng, 1.001);
                const geometry = new THREE.CircleGeometry(continent.scale, 16);
                const mesh = new THREE.Mesh(geometry, landMaterial);
                mesh.position.copy(pos);
                mesh.lookAt(0, 0, 0);
                mesh.rotateX(Math.PI);
                globeGroup.add(mesh);
            });
        }

        // ============ HELPERS ============
        function latLngToVector3(lat, lng, radius) {
            radius = radius || 1.02;
            var phi = (90 - lat) * (Math.PI / 180);
            var theta = (lng + 180) * (Math.PI / 180);
            return new THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // ============ CITY MARKERS ============
        function createCityMarkers() {
            cities.forEach(function(city, index) {
                if (city.name === "Worldwide") return;
                
                var position = latLngToVector3(city.lat, city.lng, 1.01);
                var markerGroup = new THREE.Group();
                
                // Positionner le groupe sur le globe
                markerGroup.position.copy(position);
                
                // Orienter le marqueur pour qu'il pointe vers l'ext√©rieur du globe
                var up = position.clone().normalize();
                var quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);
                markerGroup.setRotationFromQuaternion(quaternion);

                // === BASE DU PIN (cercle au sol) ===
                var baseRingGeometry = new THREE.RingGeometry(0.015, 0.022, 32);
                var baseRingMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                var baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
                baseRing.rotation.x = -Math.PI / 2;
                baseRing.position.y = 0.002;
                markerGroup.add(baseRing);

                // === TIGE DU PIN ===
                var stemGeometry = new THREE.CylinderGeometry(0.004, 0.006, 0.05, 8);
                var stemMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0x333333,
                    emissiveIntensity: 0.2,
                    shininess: 80
                });
                var stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 0.027;
                markerGroup.add(stem);

                // === T√äTE DU PIN (goutte/ballon) ===
                var headGeometry = new THREE.SphereGeometry(0.022, 32, 32);
                var headMaterial = new THREE.MeshPhongMaterial({
                    color: city.color,
                    emissive: city.color,
                    emissiveIntensity: 0.4,
                    shininess: 100,
                    specular: 0xffffff
                });
                var head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 0.07;
                markerGroup.add(head);

                // === REFLET SUR LA T√äTE ===
                var highlightGeometry = new THREE.SphereGeometry(0.008, 16, 16);
                var highlightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });
                var highlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
                highlight.position.set(-0.008, 0.078, 0.012);
                markerGroup.add(highlight);

                // === GLOW AUTOUR DE LA T√äTE ===
                var glowGeometry = new THREE.SphereGeometry(0.035, 16, 16);
                var glowMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    transparent: true,
                    opacity: 0.15
                });
                var glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.y = 0.07;
                markerGroup.add(glow);

                // === ANNEAU LUMINEUX √Ä LA BASE ===
                var pulseRingGeometry = new THREE.RingGeometry(0.025, 0.035, 32);
                var pulseRingMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                var pulseRing = new THREE.Mesh(pulseRingGeometry, pulseRingMaterial);
                pulseRing.rotation.x = -Math.PI / 2;
                pulseRing.position.y = 0.003;
                pulseRing.userData.isPulseRing = true;
                markerGroup.add(pulseRing);

                // === LABEL 3D ===
                var label = createCityLabel(city.name, city.flag, city.color);
                label.position.y = 0.12;
                markerGroup.add(label);

                markerGroup.userData = { cityIndex: index };
                globeGroup.add(markerGroup);
                cityMarkers.push(markerGroup);
            });
        }

        function createCityLabel(name, flag, color) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(244, 0);
            ctx.quadraticCurveTo(256, 0, 256, 12);
            ctx.lineTo(256, 52);
            ctx.quadraticCurveTo(256, 64, 244, 64);
            ctx.lineTo(12, 64);
            ctx.quadraticCurveTo(0, 64, 0, 52);
            ctx.lineTo(0, 12);
            ctx.quadraticCurveTo(0, 0, 12, 0);
            ctx.fill();

            ctx.strokeStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(flag + ' ' + name, canvas.width / 2, canvas.height / 2);

            var texture = new THREE.CanvasTexture(canvas);
            var spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.25, 0.0625, 1);
            
            return sprite;
        }

        // ============ ROUTE ============
        function createRoute() {
            var points = [];
            
            for (var i = 0; i < cities.length - 1; i++) {
                var start = latLngToVector3(cities[i].lat, cities[i].lng, 1.03);
                var end = latLngToVector3(cities[i + 1].lat, cities[i + 1].lng, 1.03);
                var arcPoints = createArc(start, end, 30);
                points = points.concat(arcPoints);
            }

            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            var material = new THREE.LineBasicMaterial({
                color: 0xf093fb,
                transparent: true,
                opacity: 0.7
            });
            var route = new THREE.Line(geometry, material);
            globeGroup.add(route);
        }

        function createArc(start, end, segments) {
            var points = [];
            for (var i = 0; i <= segments; i++) {
                var t = i / segments;
                var point = new THREE.Vector3().lerpVectors(start, end, t);
                var elevation = Math.sin(t * Math.PI) * 0.1;
                point.normalize().multiplyScalar(1.03 + elevation);
                points.push(point);
            }
            return points;
        }

        // ============ CHARGER MODELE 3D DU PERSONNAGE ============
        function loadCharacterModel() {
            var loader = new THREE.GLTFLoader();
            
            loader.load(
                CONFIG.characterModel,
                // Succ√®s
                function(gltf) {
                    console.log('‚úÖ Mod√®le personnage charg√© !');
                    character = gltf.scene;
                    character.scale.setScalar(CONFIG.characterScale);
                    
                    // Appliquer rotation si configur√©e
                    character.rotation.x = CONFIG.characterRotation.x;
                    character.rotation.y = CONFIG.characterRotation.y;
                    character.rotation.z = CONFIG.characterRotation.z;
                    
                    // Charger les animations si pr√©sentes
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        var action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                        console.log('‚úÖ Animation charg√©e !');
                    }
                    
                    globeGroup.add(character);
                    updateCharacterPosition(0);
                    updateUI();
                },
                // Progression
                function(xhr) {
                    console.log('Chargement mod√®le: ' + (xhr.loaded / xhr.total * 100) + '%');
                },
                // Erreur : cr√©er un personnage par d√©faut
                function(error) {
                    console.log('‚ö†Ô∏è Mod√®le non trouv√©, utilisation du personnage par d√©faut');
                    createFallbackCharacter();
                }
            );
        }

        // Personnage de secours si pas de mod√®le GLB
        function createFallbackCharacter() {
            character = new THREE.Group();

            var skinMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac, emissive: 0x331100, emissiveIntensity: 0.1 });

            // === BIG HEAD ===
            var headGeometry = new THREE.SphereGeometry(0.055, 32, 32);
            var head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 0.08;
            character.add(head);

            // Hair
            var hairGeometry = new THREE.SphereGeometry(0.058, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            var hairMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2718 });
            var hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.085;
            hair.rotation.x = -0.15;
            character.add(hair);

            // Eyes
            var eyeGeometry = new THREE.SphereGeometry(0.012, 16, 16);
            var eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            
            var leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.02, 0.085, 0.045);
            character.add(leftEye);

            var rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.02, 0.085, 0.045);
            character.add(rightEye);

            // Eye highlights
            var highlightGeometry = new THREE.SphereGeometry(0.005, 8, 8);
            var highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            var leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            leftHighlight.position.set(-0.016, 0.09, 0.055);
            character.add(leftHighlight);

            var rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            rightHighlight.position.set(0.024, 0.09, 0.055);
            character.add(rightHighlight);

            // === BODY ===
            var bodyGeometry = new THREE.CylinderGeometry(0.025, 0.028, 0.045, 16);
            var bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4facfe, emissive: 0x1a3a5c, emissiveIntensity: 0.3 });
            var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.01;
            character.add(body);

            // === BACKPACK ===
            var backpackGeometry = new THREE.BoxGeometry(0.03, 0.04, 0.02);
            var backpackMaterial = new THREE.MeshPhongMaterial({ color: 0xf093fb, emissive: 0x5a2060, emissiveIntensity: 0.3 });
            var backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.015, -0.035);
            character.add(backpack);

            // === LEGS ===
            var legGeometry = new THREE.CylinderGeometry(0.01, 0.012, 0.03, 8);
            var legMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015, -0.035, 0);
            character.add(leftLeg);

            var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015, -0.035, 0);
            character.add(rightLeg);

            // === CAP ===
            var capGeometry = new THREE.SphereGeometry(0.048, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            var capMaterial = new THREE.MeshPhongMaterial({ color: 0xff4757, emissive: 0x5a1a1a, emissiveIntensity: 0.2 });
            var cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 0.115;
            cap.rotation.x = -0.1;
            character.add(cap);

            globeGroup.add(character);
            updateCharacterPosition(0);
        }

        function updateCharacterPosition(progress) {
            if (!character) return;
            
            var totalCities = cities.length - 1;
            var cityProgress = progress * totalCities;
            var currentIdx = Math.min(Math.floor(cityProgress), totalCities - 1);
            var nextIdx = Math.min(currentIdx + 1, totalCities);
            var localProgress = cityProgress - currentIdx;

            var startPos = latLngToVector3(cities[currentIdx].lat, cities[currentIdx].lng, 1.15);
            var endPos = latLngToVector3(cities[nextIdx].lat, cities[nextIdx].lng, 1.15);

            character.position.lerpVectors(startPos, endPos, localProgress);
            
            var arcHeight = Math.sin(localProgress * Math.PI) * 0.04;
            character.position.normalize().multiplyScalar(1.15 + arcHeight);
            
            character.lookAt(0, 0, 0);
            character.rotateX(Math.PI / 2);
        }

        // ============ STARS ============
        function createStars() {
            var starsGeometry = new THREE.BufferGeometry();
            var starsVertices = [];
            for (var i = 0; i < 2000; i++) {
                starsVertices.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            var starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starsGeometry, starsMaterial));
        }

        // ============ CONTROLS ============
        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            targetRotation.y += (e.clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() { isDragging = false; }

        function onMouseWheel(e) {
            camera.position.z = Math.max(2, Math.min(6, camera.position.z + e.deltaY * 0.002));
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }

        function onTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            targetRotation.y += (e.touches[0].clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.touches[0].clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ COUNTER ============
        async function initCounter() {
            try {
                var response = await fetch('https://api.countapi.xyz/hit/luxstudio-events/world-tour-v5');
                var data = await response.json();
                visitorCount = data.value;
            } catch (e) {
                visitorCount = Math.floor(Math.random() * 1500) + 300;
            }
            updateUI();
        }

        function updateUI() {
            animateNumber(document.getElementById('visitorCount'), 0, visitorCount, 2000);

            currentCityIndex = 0;
            for (var i = cities.length - 1; i >= 0; i--) {
                if (visitorCount >= cities[i].threshold) {
                    currentCityIndex = i;
                    break;
                }
            }

            var currentCity = cities[currentCityIndex];
            var nextCity = cities[Math.min(currentCityIndex + 1, cities.length - 1)];

            document.getElementById('locationFlag').textContent = currentCity.flag;
            document.getElementById('locationCity').textContent = currentCity.name;
            document.getElementById('locationEvent').textContent = currentCity.event;
            document.getElementById('locationUnlock').innerHTML = '<span>üéÆ</span><span>' + currentCity.unlock + '</span>';

            var progressToNext = currentCity.threshold === nextCity.threshold ? 100 :
                ((visitorCount - currentCity.threshold) / (nextCity.threshold - currentCity.threshold)) * 100;
            
            document.getElementById('progressFill').style.width = Math.min(progressToNext, 100) + '%';
            document.getElementById('progressCurrent').textContent = currentCity.name;
            document.getElementById('progressNext').textContent = 
                currentCityIndex < cities.length - 1 ? 'Next: ' + nextCity.name + ' (' + nextCity.threshold + ')' : 'üèÜ Complete!';

            var legendHTML = '';
            cities.forEach(function(city, index) {
                var unlockedClass = visitorCount >= city.threshold ? 'unlocked' : '';
                var currentClass = index === currentCityIndex ? 'current' : '';
                legendHTML += '<div class="legend-item ' + unlockedClass + ' ' + currentClass + '">' +
                    '<span class="legend-dot"></span>' +
                    '<span>' + city.flag + ' ' + city.name + '</span>' +
                    '</div>';
            });
            document.getElementById('legendItems').innerHTML = legendHTML;

            cityMarkers.forEach(function(marker, index) {
                var unlocked = visitorCount >= cities[index].threshold;
                // La scale est g√©r√©e dans l'animation loop
                // Ici on g√®re juste l'opacit√© des mat√©riaux si non d√©bloqu√©
                marker.traverse(function(child) {
                    if (child.isMesh && child.material && !child.userData.isPulseRing) {
                        if (!unlocked) {
                            child.material.transparent = true;
                            child.material.opacity = 0.4;
                        }
                    }
                });
            });

            var maxThreshold = cities[cities.length - 1].threshold;
            updateCharacterPosition(Math.min(visitorCount / maxThreshold, 0.99));
        }

        function animateNumber(el, start, end, duration) {
            var startTime = performance.now();
            function update(currentTime) {
                var progress = Math.min((currentTime - startTime) / duration, 1);
                el.textContent = Math.floor(start + (end - start) * (1 - Math.pow(1 - progress, 3))).toLocaleString();
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        // ============ ANIMATION LOOP ============
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            var delta = clock.getDelta();

            // Update animations du mod√®le
            if (mixer) {
                mixer.update(delta);
            }

            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            globeGroup.rotation.x = currentRotation.x;
            globeGroup.rotation.y = currentRotation.y;

            if (!isDragging) targetRotation.y += 0.001;

            // Character bobbing
            if (character) {
                character.position.y += Math.sin(time * 4) * 0.0002;
            }

            // Pulse current city marker + animate rings
            cityMarkers.forEach(function(marker, index) {
                var isCurrent = index === currentCityIndex;
                var isUnlocked = visitorCount >= cities[index].threshold;
                
                // Scale du marqueur
                if (isCurrent) {
                    marker.scale.setScalar(1.3 + Math.sin(time * 3) * 0.1);
                } else {
                    marker.scale.setScalar(isUnlocked ? 1 : 0.6);
                }
                
                // Animation des anneaux pulse
                marker.traverse(function(child) {
                    if (child.userData && child.userData.isPulseRing) {
                        if (isCurrent) {
                            var pulseScale = 1 + Math.sin(time * 2) * 0.3;
                            child.scale.set(pulseScale, pulseScale, 1);
                            child.material.opacity = 0.4 - Math.sin(time * 2) * 0.2;
                        } else {
                            child.scale.set(1, 1, 1);
                            child.material.opacity = isUnlocked ? 0.2 : 0.1;
                        }
                    }
                });
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
