<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming Events World Tour</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3e 50%, #0c0c1e 100%);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .header-stats {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
        }

        .travelers-count {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #667eea);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 4s ease infinite;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .travelers-label {
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-top: 5px;
        }

        .current-location {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .location-flag {
            font-size: 40px;
            margin-bottom: 8px;
        }

        .location-city {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .location-event {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 12px;
        }

        .location-unlock {
            font-size: 13px;
            color: #f093fb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .progress-container {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.6;
        }

        .cities-legend {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .legend-title {
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 13px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .legend-item.unlocked { opacity: 1; }
        .legend-item.current { opacity: 1; color: #f093fb; }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }

        .legend-item.unlocked .legend-dot {
            background: #4facfe;
            box-shadow: 0 0 10px #4facfe;
        }

        .legend-item.current .legend-dot {
            background: #f093fb;
            box-shadow: 0 0 10px #f093fb;
            animation: pulse-dot 1s ease infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            opacity: 0.5;
        }

        @media (max-width: 768px) {
            .cities-legend { display: none; }
            .travelers-count { font-size: 36px; }
            .current-location { padding: 15px 25px; }
            .location-city { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="ui-overlay">
        <div class="header-stats">
            <div class="travelers-count" id="visitorCount">0</div>
            <div class="travelers-label">üåç World Travelers</div>
        </div>

        <div class="instructions">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom</div>

        <div class="cities-legend">
            <div class="legend-title">üó∫Ô∏è World Tour</div>
            <div id="legendItems"></div>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-labels">
                <span id="progressCurrent">Paris</span>
                <span id="progressNext">Next: Cologne</span>
            </div>
        </div>

        <div class="current-location">
            <div class="location-flag" id="locationFlag">üá´üá∑</div>
            <div class="location-city" id="locationCity">Paris</div>
            <div class="location-event" id="locationEvent">Paris Games Week</div>
            <div class="location-unlock" id="locationUnlock">
                <span>üéÆ</span>
                <span>L'aventure commence !</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ============ CITIES DATA ============
        const cities = [
            { name: "Paris", flag: "üá´üá∑", event: "Paris Games Week", unlock: "L'aventure commence !", lat: 48.8566, lng: 2.3522, threshold: 0, color: 0x667eea },
            { name: "Cologne", flag: "üá©üá™", event: "Gamescom", unlock: "üé´ Premier event d√©bloqu√© !", lat: 50.9375, lng: 6.9603, threshold: 100, color: 0xffcc00 },
            { name: "London", flag: "üá¨üáß", event: "PG Connects London", unlock: "üó∫Ô∏è New territory unlocked !", lat: 51.5074, lng: -0.1278, threshold: 300, color: 0xff6b6b },
            { name: "San Francisco", flag: "üá∫üá∏", event: "GDC", unlock: "üé¨ Dev zone reached !", lat: 37.7749, lng: -122.4194, threshold: 600, color: 0x4facfe },
            { name: "Los Angeles", flag: "üá∫üá∏", event: "Summer Game Fest", unlock: "‚≠ê Hollywood level !", lat: 34.0522, lng: -118.2437, threshold: 1000, color: 0xf093fb },
            { name: "Tokyo", flag: "üáØüáµ", event: "Tokyo Game Show", unlock: "üèÜ Legendary destination !", lat: 35.6762, lng: 139.6503, threshold: 2000, color: 0xff4757 },
            { name: "Bali", flag: "üáÆüá©", event: "IGDX", unlock: "üèùÔ∏è Hidden gem found !", lat: -8.3405, lng: 115.0920, threshold: 3500, color: 0x2ed573 },
            { name: "Worldwide", flag: "üåç", event: "Global Domination", unlock: "üöÄ You've conquered the world !", lat: 0, lng: 0, threshold: 5000, color: 0xffd700 }
        ];

        // ============ THREE.JS VARIABLES ============
        let scene, camera, renderer, globeGroup;
        let cityMarkers = [];
        let character;
        let targetRotation = { x: 0.3, y: 0 };
        let currentRotation = { x: 0.3, y: 0 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let visitorCount = 0;
        let currentCityIndex = 0;
        let time = 0;

        // ============ INIT ============
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            createGlobe();
            createCityMarkers();
            createRoute();
            createChibiCharacter();
            createStars();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x4facfe, 0.4);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onMouseUp);

            initCounter();
            animate();
        }

        // ============ GLOBE ============
        function createGlobe() {
            // Main globe - ocean color
            const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
            const globeMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a4a7a,
                emissive: 0x0a1a2a,
                emissiveIntensity: 0.3,
                shininess: 10
            });
            const globe = new THREE.Mesh(globeGeometry, globeMaterial);
            globeGroup.add(globe);

            // Land masses
            createContinents();

            // Wireframe grid
            const wireGeometry = new THREE.SphereGeometry(1.005, 36, 18);
            const wireMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                wireframe: true,
                transparent: true,
                opacity: 0.1
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            globeGroup.add(wireframe);

            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(1.15, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            globeGroup.add(atmosphere);
        }

        function createContinents() {
            const continentData = [
                { lat: 50, lng: 10, scale: 0.15 },
                { lat: 45, lng: 0, scale: 0.12 },
                { lat: 55, lng: 20, scale: 0.1 },
                { lat: 35, lng: 100, scale: 0.25 },
                { lat: 50, lng: 80, scale: 0.2 },
                { lat: 25, lng: 120, scale: 0.15 },
                { lat: 40, lng: 140, scale: 0.1 },
                { lat: 45, lng: -100, scale: 0.22 },
                { lat: 35, lng: -90, scale: 0.18 },
                { lat: 55, lng: -110, scale: 0.15 },
                { lat: -15, lng: -60, scale: 0.18 },
                { lat: -30, lng: -65, scale: 0.12 },
                { lat: 10, lng: 20, scale: 0.2 },
                { lat: -10, lng: 25, scale: 0.15 },
                { lat: 25, lng: 30, scale: 0.1 },
                { lat: -25, lng: 135, scale: 0.14 },
                { lat: -5, lng: 115, scale: 0.1 },
                { lat: 0, lng: 125, scale: 0.08 },
            ];

            const landMaterial = new THREE.MeshPhongMaterial({
                color: 0x2d5a3d,
                emissive: 0x1a3320,
                emissiveIntensity: 0.2
            });

            continentData.forEach(continent => {
                const pos = latLngToVector3(continent.lat, continent.lng, 1.001);
                const geometry = new THREE.CircleGeometry(continent.scale, 16);
                const mesh = new THREE.Mesh(geometry, landMaterial);
                mesh.position.copy(pos);
                mesh.lookAt(0, 0, 0);
                mesh.rotateX(Math.PI);
                globeGroup.add(mesh);
            });
        }

        // ============ HELPERS ============
        function latLngToVector3(lat, lng, radius = 1.02) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lng + 180) * (Math.PI / 180);
            return new THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // ============ CITY MARKERS ============
        function createCityMarkers() {
            cities.forEach((city, index) => {
                if (city.name === "Worldwide") return;
                
                const position = latLngToVector3(city.lat, city.lng, 1.02);
                const markerGroup = new THREE.Group();
                markerGroup.position.copy(position);
                markerGroup.lookAt(0, 0, 0);
                markerGroup.rotateX(Math.PI);

                // Pin base
                const pinGeometry = new THREE.CylinderGeometry(0.01, 0.018, 0.06, 8);
                const pinMaterial = new THREE.MeshPhongMaterial({
                    color: city.color,
                    emissive: city.color,
                    emissiveIntensity: 0.4
                });
                const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                pin.position.y = 0.03;
                markerGroup.add(pin);

                // Glowing top sphere
                const sphereGeometry = new THREE.SphereGeometry(0.025, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: city.color,
                    emissive: city.color,
                    emissiveIntensity: 0.6,
                    transparent: true,
                    opacity: 0.95
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.y = 0.08;
                markerGroup.add(sphere);

                // Outer glow
                const glowGeometry = new THREE.SphereGeometry(0.045, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    transparent: true,
                    opacity: 0.25
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                sphere.add(glow);

                // 3D Label
                const label = createCityLabel(city.name, city.flag, city.color);
                label.position.y = 0.18;
                markerGroup.add(label);

                markerGroup.userData = { cityIndex: index };
                globeGroup.add(markerGroup);
                cityMarkers.push(markerGroup);
            });
        }

        function createCityLabel(name, flag, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(244, 0);
            ctx.quadraticCurveTo(256, 0, 256, 12);
            ctx.lineTo(256, 52);
            ctx.quadraticCurveTo(256, 64, 244, 64);
            ctx.lineTo(12, 64);
            ctx.quadraticCurveTo(0, 64, 0, 52);
            ctx.lineTo(0, 12);
            ctx.quadraticCurveTo(0, 0, 12, 0);
            ctx.fill();

            ctx.strokeStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(flag + ' ' + name, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.25, 0.0625, 1);
            
            return sprite;
        }

        // ============ ROUTE ============
        function createRoute() {
            const points = [];
            
            for (let i = 0; i < cities.length - 1; i++) {
                const start = latLngToVector3(cities[i].lat, cities[i].lng, 1.03);
                const end = latLngToVector3(cities[i + 1].lat, cities[i + 1].lng, 1.03);
                const arcPoints = createArc(start, end, 30);
                points.push(...arcPoints);
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xf093fb,
                transparent: true,
                opacity: 0.7
            });
            const route = new THREE.Line(geometry, material);
            globeGroup.add(route);
        }

        function createArc(start, end, segments) {
            const points = [];
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const point = new THREE.Vector3().lerpVectors(start, end, t);
                const elevation = Math.sin(t * Math.PI) * 0.1;
                point.normalize().multiplyScalar(1.03 + elevation);
                points.push(point);
            }
            return points;
        }

        // ============ CHIBI CHARACTER (sans CapsuleGeometry) ============
        function createChibiCharacter() {
            character = new THREE.Group();

            const skinMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac, emissive: 0x331100, emissiveIntensity: 0.1 });

            // === BIG HEAD ===
            const headGeometry = new THREE.SphereGeometry(0.055, 32, 32);
            const head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 0.08;
            character.add(head);

            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.058, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            const hairMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2718 });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.085;
            hair.rotation.x = -0.15;
            character.add(hair);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.012, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.02, 0.085, 0.045);
            character.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.02, 0.085, 0.045);
            character.add(rightEye);

            // Eye highlights
            const highlightGeometry = new THREE.SphereGeometry(0.005, 8, 8);
            const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            leftHighlight.position.set(-0.016, 0.09, 0.055);
            character.add(leftHighlight);

            const rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            rightHighlight.position.set(0.024, 0.09, 0.055);
            character.add(rightHighlight);

            // Cheeks (blush)
            const cheekGeometry = new THREE.CircleGeometry(0.012, 16);
            const cheekMaterial = new THREE.MeshBasicMaterial({ color: 0xffaaaa, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            
            const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
            leftCheek.position.set(-0.04, 0.065, 0.048);
            leftCheek.lookAt(0, 0.065, 1);
            character.add(leftCheek);

            const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
            rightCheek.position.set(0.04, 0.065, 0.048);
            rightCheek.lookAt(0, 0.065, 1);
            character.add(rightCheek);

            // Mouth (smile)
            const smileGeometry = new THREE.TorusGeometry(0.012, 0.003, 8, 16, Math.PI);
            const smileMaterial = new THREE.MeshBasicMaterial({ color: 0xff6666 });
            const smile = new THREE.Mesh(smileGeometry, smileMaterial);
            smile.position.set(0, 0.055, 0.05);
            smile.rotation.x = Math.PI / 2;
            smile.rotation.z = Math.PI;
            character.add(smile);

            // === BODY (using cylinder + spheres instead of capsule) ===
            const bodyGeometry = new THREE.CylinderGeometry(0.025, 0.028, 0.045, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4facfe, emissive: 0x1a3a5c, emissiveIntensity: 0.3 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.01;
            character.add(body);

            // Body top sphere
            const bodyTopGeometry = new THREE.SphereGeometry(0.025, 16, 16);
            const bodyTop = new THREE.Mesh(bodyTopGeometry, bodyMaterial);
            bodyTop.position.y = 0.032;
            character.add(bodyTop);

            // Body bottom sphere
            const bodyBottomGeometry = new THREE.SphereGeometry(0.028, 16, 16);
            const bodyBottom = new THREE.Mesh(bodyBottomGeometry, bodyMaterial);
            bodyBottom.position.y = -0.012;
            character.add(bodyBottom);

            // === BACKPACK ===
            const backpackGeometry = new THREE.BoxGeometry(0.03, 0.04, 0.02);
            const backpackMaterial = new THREE.MeshPhongMaterial({ color: 0xf093fb, emissive: 0x5a2060, emissiveIntensity: 0.3 });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.015, -0.035);
            character.add(backpack);

            // === LEGS (cylinders instead of capsules) ===
            const legGeometry = new THREE.CylinderGeometry(0.01, 0.012, 0.03, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015, -0.035, 0);
            character.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015, -0.035, 0);
            character.add(rightLeg);

            // Shoes
            const shoeGeometry = new THREE.SphereGeometry(0.013, 8, 8);
            const shoeMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.015, -0.05, 0.005);
            character.add(leftShoe);

            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.015, -0.05, 0.005);
            character.add(rightShoe);

            // === ARMS (cylinders) ===
            const armGeometry = new THREE.CylinderGeometry(0.008, 0.008, 0.03, 8);
            
            const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
            leftArm.position.set(-0.04, 0.015, 0);
            leftArm.rotation.z = 0.5;
            character.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
            rightArm.position.set(0.04, 0.015, 0);
            rightArm.rotation.z = -0.5;
            character.add(rightArm);

            // Hands
            const handGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            
            const leftHand = new THREE.Mesh(handGeometry, skinMaterial);
            leftHand.position.set(-0.052, 0, 0);
            character.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, skinMaterial);
            rightHand.position.set(0.052, 0, 0);
            character.add(rightHand);

            // === CAP ===
            const capGeometry = new THREE.SphereGeometry(0.048, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const capMaterial = new THREE.MeshPhongMaterial({ color: 0xff4757, emissive: 0x5a1a1a, emissiveIntensity: 0.2 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 0.115;
            cap.rotation.x = -0.1;
            character.add(cap);

            // Cap brim
            const brimGeometry = new THREE.CylinderGeometry(0.035, 0.035, 0.008, 16);
            const brim = new THREE.Mesh(brimGeometry, capMaterial);
            brim.position.set(0, 0.1, 0.04);
            brim.rotation.x = -0.4;
            character.add(brim);

            // Cap button
            const buttonGeometry = new THREE.SphereGeometry(0.008, 8, 8);
            const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
            button.position.y = 0.155;
            character.add(button);

            updateCharacterPosition(0);
            globeGroup.add(character);
        }

        function updateCharacterPosition(progress) {
            const totalCities = cities.length - 1;
            const cityProgress = progress * totalCities;
            const currentIdx = Math.min(Math.floor(cityProgress), totalCities - 1);
            const nextIdx = Math.min(currentIdx + 1, totalCities);
            const localProgress = cityProgress - currentIdx;

            const startPos = latLngToVector3(cities[currentIdx].lat, cities[currentIdx].lng, 1.15);
            const endPos = latLngToVector3(cities[nextIdx].lat, cities[nextIdx].lng, 1.15);

            character.position.lerpVectors(startPos, endPos, localProgress);
            
            const arcHeight = Math.sin(localProgress * Math.PI) * 0.04;
            character.position.normalize().multiplyScalar(1.15 + arcHeight);
            
            character.lookAt(0, 0, 0);
            character.rotateX(Math.PI / 2);
        }

        // ============ STARS ============
        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            for (let i = 0; i < 2000; i++) {
                starsVertices.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 });
            scene.add(new THREE.Points(starsGeometry, starsMaterial));
        }

        // ============ CONTROLS ============
        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            targetRotation.y += (e.clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() { isDragging = false; }

        function onMouseWheel(e) {
            camera.position.z = Math.max(2, Math.min(6, camera.position.z + e.deltaY * 0.002));
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }

        function onTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            targetRotation.y += (e.touches[0].clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.touches[0].clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ COUNTER ============
        async function initCounter() {
            try {
                const response = await fetch('https://api.countapi.xyz/hit/luxstudio-events/world-tour-v4');
                const data = await response.json();
                visitorCount = data.value;
            } catch (e) {
                visitorCount = Math.floor(Math.random() * 1500) + 300;
            }
            updateUI();
        }

        function updateUI() {
            animateNumber(document.getElementById('visitorCount'), 0, visitorCount, 2000);

            currentCityIndex = 0;
            for (let i = cities.length - 1; i >= 0; i--) {
                if (visitorCount >= cities[i].threshold) {
                    currentCityIndex = i;
                    break;
                }
            }

            const currentCity = cities[currentCityIndex];
            const nextCity = cities[Math.min(currentCityIndex + 1, cities.length - 1)];

            document.getElementById('locationFlag').textContent = currentCity.flag;
            document.getElementById('locationCity').textContent = currentCity.name;
            document.getElementById('locationEvent').textContent = currentCity.event;
            document.getElementById('locationUnlock').innerHTML = '<span>üéÆ</span><span>' + currentCity.unlock + '</span>';

            const progressToNext = currentCity.threshold === nextCity.threshold ? 100 :
                ((visitorCount - currentCity.threshold) / (nextCity.threshold - currentCity.threshold)) * 100;
            
            document.getElementById('progressFill').style.width = Math.min(progressToNext, 100) + '%';
            document.getElementById('progressCurrent').textContent = currentCity.name;
            document.getElementById('progressNext').textContent = 
                currentCityIndex < cities.length - 1 ? 'Next: ' + nextCity.name + ' (' + nextCity.threshold + ')' : 'üèÜ Complete!';

            let legendHTML = '';
            cities.forEach(function(city, index) {
                const unlockedClass = visitorCount >= city.threshold ? 'unlocked' : '';
                const currentClass = index === currentCityIndex ? 'current' : '';
                legendHTML += '<div class="legend-item ' + unlockedClass + ' ' + currentClass + '">' +
                    '<span class="legend-dot"></span>' +
                    '<span>' + city.flag + ' ' + city.name + '</span>' +
                    '</div>';
            });
            document.getElementById('legendItems').innerHTML = legendHTML;

            cityMarkers.forEach(function(marker, index) {
                const unlocked = visitorCount >= cities[index].threshold;
                marker.scale.setScalar(index === currentCityIndex ? 1.4 : (unlocked ? 1 : 0.6));
            });

            const maxThreshold = cities[cities.length - 1].threshold;
            updateCharacterPosition(Math.min(visitorCount / maxThreshold, 0.99));
        }

        function animateNumber(el, start, end, duration) {
            const startTime = performance.now();
            function update(currentTime) {
                const progress = Math.min((currentTime - startTime) / duration, 1);
                el.textContent = Math.floor(start + (end - start) * (1 - Math.pow(1 - progress, 3))).toLocaleString();
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        // ============ ANIMATION LOOP ============
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            globeGroup.rotation.x = currentRotation.x;
            globeGroup.rotation.y = currentRotation.y;

            if (!isDragging) targetRotation.y += 0.001;

            // Character bobbing
            if (character) {
                character.position.y += Math.sin(time * 4) * 0.0002;
            }

            // Pulse current city marker
            cityMarkers.forEach(function(marker, index) {
                if (index === currentCityIndex) {
                    marker.scale.setScalar(1.4 + Math.sin(time * 3) * 0.15);
                }
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
