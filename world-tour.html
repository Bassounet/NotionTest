<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming Events World Tour</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a3e 50%, #0c0c1e 100%);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #canvas-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .header-stats {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
        }

        .travelers-count {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb, #667eea);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradient-shift 4s ease infinite;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .travelers-label {
            font-size: 14px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.8;
            margin-top: 5px;
        }

        .current-location {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px 40px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .current-location:hover {
            background: rgba(0, 0, 0, 0.7);
            border-color: rgba(240, 147, 251, 0.3);
            transform: translateX(-50%) translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .location-flag {
            font-size: 40px;
            margin-bottom: 8px;
        }

        .location-city {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .location-event {
            font-size: 14px;
            opacity: 0.7;
            margin-bottom: 12px;
        }

        .location-unlock {
            font-size: 13px;
            color: #f093fb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .progress-container {
            position: absolute;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            opacity: 0.6;
        }

        .cities-legend {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
        }

        .legend-title {
            font-size: 12px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.6;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 13px;
            opacity: 0.5;
            transition: opacity 0.3s;
            cursor: pointer;
        }

        .legend-item:hover {
            opacity: 1 !important;
        }

        .legend-item.unlocked { opacity: 1; }
        .legend-item.current { opacity: 1; color: #f093fb; }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
        }

        .legend-item.unlocked .legend-dot {
            background: #4facfe;
            box-shadow: 0 0 10px #4facfe;
        }

        .legend-item.current .legend-dot {
            background: #f093fb;
            box-shadow: 0 0 10px #f093fb;
            animation: pulse-dot 1s ease infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            opacity: 0.5;
        }

        /* ============ HOVER TOOLTIP ============ */
        .hover-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transform: translateY(5px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 100;
            white-space: nowrap;
        }

        .hover-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .hover-tooltip-flag {
            margin-right: 6px;
        }

        .hover-tooltip-event {
            font-size: 10px;
            opacity: 0.6;
            margin-top: 2px;
        }

        @media (max-width: 768px) {
            .cities-legend { display: none; }
            .travelers-count { font-size: 36px; }
            .travelers-label { font-size: 12px; letter-spacing: 2px; }
            
            .current-location {
                padding: 12px 20px;
                width: 90%;
                max-width: 320px;
                bottom: 20px;
                border-radius: 16px;
            }
            .location-flag { font-size: 28px; margin-bottom: 4px; }
            .location-city { font-size: 18px; }
            .location-event { font-size: 12px; margin-bottom: 8px; }
            .location-unlock { font-size: 11px; }
            
            .progress-container {
                width: 90%;
                bottom: 120px;
            }
            .progress-labels { font-size: 10px; }
            
            .instructions { display: none; }
        }

        @media (max-width: 480px) {
            .travelers-count { font-size: 28px; }
            .travelers-label { font-size: 10px; letter-spacing: 1px; }
            
            .current-location {
                padding: 10px 15px;
                bottom: 15px;
            }
            .location-flag { font-size: 24px; }
            .location-city { font-size: 16px; }
            .location-event { font-size: 11px; }
            .location-unlock { font-size: 10px; gap: 4px; }
            
            .progress-container {
                bottom: 100px;
            }
            .progress-bar { height: 6px; }
            .progress-labels { font-size: 9px; }
        }

        @media (max-height: 600px) {
            .current-location {
                padding: 8px 15px;
                bottom: 10px;
            }
            .location-flag { font-size: 20px; margin-bottom: 2px; }
            .location-city { font-size: 14px; margin-bottom: 2px; }
            .location-event { font-size: 10px; margin-bottom: 6px; }
            .location-unlock { font-size: 10px; }
            
            .progress-container { bottom: 85px; }
            .header-stats { top: 10px; }
        }

        /* ============ CONTROL PANEL ============ */
        .control-panel {
            position: absolute;
            top: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            overflow: hidden;
            transition: all 0.3s ease;
            font-size: 10px;
            z-index: 50;
        }

        .control-panel.collapsed {
            width: auto;
            min-width: 44px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-panel.collapsed .control-toggle {
            justify-content: center;
            padding: 12px 14px;
        }

        .control-panel.collapsed .control-content {
            display: none;
        }

        .control-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: background 0.2s;
            gap: 8px;
        }

        .control-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .control-toggle-text {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .control-toggle-icon {
            font-size: 20px;
            transition: transform 0.5s ease;
        }

        .control-panel:not(.collapsed) .control-toggle-icon {
            transform: rotate(180deg);
        }

        .control-panel.collapsed .control-toggle-icon {
            animation: gear-pulse 2s ease-in-out infinite;
        }

        @keyframes gear-pulse {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(45deg); }
        }

        .control-panel.collapsed .control-toggle-text {
            display: none;
        }

        .control-content {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 160px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .control-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(255, 255, 255, 0.6);
        }

        .control-value {
            color: #f093fb;
            font-weight: 600;
        }

        .control-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            cursor: pointer;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #f093fb);
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #f093fb);
            cursor: pointer;
            border: none;
        }

        .control-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 2px 0;
        }

        .control-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-size: 200% 200%;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: gradient-shift 4s ease infinite;
        }

        .control-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .control-button:active {
            transform: translateY(0) scale(0.98);
        }

        .control-button-icon {
            font-size: 12px;
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .control-checkbox input {
            display: none;
        }

        .control-checkbox-box {
            width: 14px;
            height: 14px;
            border-radius: 4px;
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .control-checkbox input:checked + .control-checkbox-box {
            background: linear-gradient(135deg, #667eea, #f093fb);
            border-color: transparent;
        }

        .control-checkbox-box::after {
            content: '‚úì';
            color: white;
            font-size: 8px;
            font-weight: bold;
            opacity: 0;
            transform: scale(0);
            transition: all 0.2s;
        }

        .control-checkbox input:checked + .control-checkbox-box::after {
            opacity: 1;
            transform: scale(1);
        }

        .control-checkbox-text {
            font-size: 9px;
            color: rgba(255, 255, 255, 0.8);
        }

        @media (max-width: 768px) {
            .control-panel {
                top: auto;
                bottom: 210px;
                left: 10px;
                font-size: 9px;
            }
            
            .control-content {
                min-width: 140px;
                padding: 8px;
                gap: 8px;
            }
            
            .control-toggle {
                padding: 6px 8px;
            }
            
            .control-button {
                padding: 6px 10px;
                font-size: 9px;
            }
        }

        @media (max-width: 480px) {
            .control-panel {
                bottom: 175px;
            }
            
            .control-content {
                min-width: 130px;
                padding: 6px;
                gap: 6px;
            }
            
            .control-label {
                font-size: 8px;
            }
            
            .control-checkbox-text {
                font-size: 8px;
            }
            
            .control-button {
                padding: 5px 8px;
                font-size: 8px;
                gap: 4px;
            }
            
            .control-button-icon {
                font-size: 10px;
            }
        }

        /* ============ EVENT MODAL ============ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            backdrop-filter: blur(0px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: none;
            transition: background 0.4s ease, backdrop-filter 0.4s ease;
        }

        .modal-overlay.active {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            pointer-events: auto;
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.95) 0%, rgba(40, 30, 60, 0.95) 100%);
            border-radius: 24px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(102, 126, 234, 0.2);
            opacity: 0;
            transform: scale(0.3);
            transition: opacity 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: absolute;
        }

        .modal-overlay.active .modal-content {
            opacity: 1;
            transform: scale(1);
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) scale(1) !important;
        }

        .modal-overlay:not(.active) .modal-content {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.3);
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-flag {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 800;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #667eea, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-dates {
            font-size: 16px;
            color: #f093fb;
            font-weight: 600;
        }

        .modal-event-number {
            font-size: 11px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 4px 12px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 10px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .modal-highlights {
            margin: 5px 0 0 0;
            padding-left: 18px;
            font-size: 13px;
            opacity: 0.9;
            list-style-type: '‚úì ';
        }

        .modal-highlights li {
            margin-bottom: 5px;
            padding-left: 5px;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .modal-row {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .modal-icon {
            font-size: 20px;
            width: 30px;
            text-align: center;
            flex-shrink: 0;
        }

        .modal-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 3px;
        }

        .modal-value {
            font-size: 14px;
            color: white;
            line-height: 1.5;
        }

        .modal-description {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            margin-top: 5px;
        }

        .modal-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 5px;
        }

        .modal-tag {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.3), rgba(240, 147, 251, 0.3));
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-website {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: 600;
            font-size: 14px;
            margin-top: 10px;
            transition: all 0.3s ease;
            justify-content: center;
        }

        .modal-website:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .modal-locked {
            text-align: center;
            padding: 40px 20px;
        }

        .modal-locked-icon {
            font-size: 60px;
            margin-bottom: 15px;
        }

        .modal-locked-text {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 10px;
        }

        .modal-locked-requirement {
            font-size: 14px;
            color: #f093fb;
            font-weight: 600;
        }

        @media (max-width: 480px) {
            .modal-content {
                padding: 20px;
                border-radius: 20px;
            }
            .modal-flag { font-size: 40px; }
            .modal-title { font-size: 20px; }
            .modal-dates { font-size: 14px; }
            .modal-value { font-size: 13px; }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- HOVER TOOLTIP -->
    <div class="hover-tooltip" id="hoverTooltip">
        <span class="hover-tooltip-flag" id="tooltipFlag">üá´üá∑</span>
        <span id="tooltipName">Paris</span>
        <div class="hover-tooltip-event" id="tooltipEvent">Paris Games Week</div>
    </div>
    
    <div class="ui-overlay">
        <div class="header-stats">
            <div class="travelers-count" id="visitorCount">0</div>
            <div class="travelers-label">üéÆ Events Visited</div>
        </div>

        <div class="instructions">üñ±Ô∏è Drag to rotate ‚Ä¢ Scroll to zoom</div>

        <!-- CONTROL PANEL -->
        <div class="control-panel collapsed" id="controlPanel">
            <div class="control-toggle" onclick="toggleControlPanel()">
                <span class="control-toggle-icon">‚öôÔ∏è</span>
                <span class="control-toggle-text">Settings</span>
            </div>
            <div class="control-content">
                <!-- Marker Size -->
                <div class="control-group">
                    <div class="control-label">
                        <span>üìç Markers</span>
                        <span class="control-value" id="markerSizeValue">100%</span>
                    </div>
                    <input type="range" class="control-slider" id="markerSizeSlider" 
                           min="50" max="200" value="100" oninput="updateMarkerSize(this.value)">
                </div>

                <!-- Rotation Speed -->
                <div class="control-group">
                    <div class="control-label">
                        <span>üåç Speed</span>
                        <span class="control-value" id="rotationSpeedValue">100%</span>
                    </div>
                    <input type="range" class="control-slider" id="rotationSpeedSlider" 
                           min="0" max="300" value="100" oninput="updateRotationSpeed(this.value)">
                </div>

                <!-- Globe Zoom -->
                <div class="control-group">
                    <div class="control-label">
                        <span>üîç Zoom</span>
                        <span class="control-value" id="zoomValue">100%</span>
                    </div>
                    <input type="range" class="control-slider" id="zoomSlider" 
                           min="50" max="150" value="100" oninput="updateZoom(this.value)">
                </div>

                <!-- Stars Density -->
                <div class="control-group">
                    <div class="control-label">
                        <span>‚ú® Stars</span>
                        <span class="control-value" id="starsValue">100%</span>
                    </div>
                    <input type="range" class="control-slider" id="starsSlider" 
                           min="0" max="200" value="100" oninput="updateStars(this.value)">
                </div>

                <div class="control-divider"></div>

                <!-- Checkboxes -->
                <label class="control-checkbox">
                    <input type="checkbox" id="autoRotateCheck" checked onchange="toggleAutoRotate(this.checked)">
                    <span class="control-checkbox-box"></span>
                    <span class="control-checkbox-text">Auto-rotate</span>
                </label>

                <label class="control-checkbox">
                    <input type="checkbox" id="showLabelsCheck" checked onchange="toggleLabels(this.checked)">
                    <span class="control-checkbox-box"></span>
                    <span class="control-checkbox-text">Labels</span>
                </label>

                <div class="control-divider"></div>

                <!-- Random Button -->
                <button class="control-button" onclick="pickRandom()">
                    <span class="control-button-icon">üé≤</span>
                    <span>Random</span>
                </button>
            </div>
        </div>

        <div class="cities-legend">
            <div class="legend-title">üó∫Ô∏è World Tour</div>
            <div id="legendItems"></div>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div class="progress-labels">
                <span id="progressCurrent">Paris</span>
                <span id="progressNext">Next: Cologne</span>
            </div>
        </div>

        <div class="current-location" id="currentLocationCard" onclick="openModal(currentCityIndex, event.clientX, event.clientY)">
            <div class="location-flag" id="locationFlag">üá´üá∑</div>
            <div class="location-city" id="locationCity">Paris</div>
            <div class="location-event" id="locationEvent">Paris Games Week</div>
            <div class="location-unlock" id="locationUnlock">
                <span>üéÆ</span>
                <span>L'aventure commence !</span>
            </div>
        </div>
    </div>

    <!-- EVENT MODAL -->
    <div class="modal-overlay" id="eventModal" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="modalInner">
                <!-- Contenu g√©n√©r√© dynamiquement -->
            </div>
        </div>
    </div>

    <!-- Three.js + GLTFLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // ============================================================
        // CONFIGURATION - MODIFIE CES CHEMINS SELON TES FICHIERS
        // ============================================================
        const CONFIG = {
            // Texture de la Terre (mettre le chemin vers ton fichier)
            earthTexture: 'rss/earth_texture.jpg',
            
            // Mod√®le 3D du personnage (mettre le chemin vers ton fichier GLB)
            characterModel: 'models/character.glb',
            
            // Taille du personnage (ajuste selon ton mod√®le)
            characterScale: 0.05,
            
            // Rotation initiale du personnage (en radians)
            characterRotation: { x: 0, y: 0, z: 0 },
            
            // CALIBRATION : D√©calage de longitude pour aligner les villes sur la texture
            // Ajuste cette valeur si les villes ne sont pas au bon endroit
            // Essaie : 0, 90, -90, 180, -180 jusqu'√† ce que Paris soit en France
            longitudeOffset: 0
        };
        // ============================================================

        // ============================================================
        // üéÆ MES √âV√âNEMENTS - AJOUTE TES EVENTS ICI
        // ============================================================
        // Les √©v√©nements sont automatiquement tri√©s par date
        // Copie un bloc et remplis les infos pour ajouter un nouvel event
        // ============================================================
        
        const MY_EVENTS = [
            // ========== 2024 ==========
            {
                date: "2024-03-18",
                city: "San Francisco",
                country: "USA",
                flag: "üá∫üá∏",
                lat: 37.7749,
                lng: -122.4194,
                color: 0x4facfe,
                building: "goldengate",
                event: {
                    name: "GDC 2024",
                    fullName: "Game Developers Conference 2024",
                    dates: "18 - 22 Mars 2024",
                    venue: "Moscone Center, San Francisco",
                    website: "https://gdconf.com",
                    description: "Point de d√©part de mon World Tour gaming !",
                    type: "B2B / Developers",
                    tags: ["Dev", "Networking", "UE5"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2024-04-23",
                city: "Prague",
                country: "Czech Republic",
                flag: "üá®üáø",
                lat: 50.0755,
                lng: 14.4378,
                color: 0x9b59b6,
                building: "cathedral",
                event: {
                    name: "Unreal Fest Prague 2024",
                    fullName: "Unreal Fest Prague 2024",
                    dates: "23 - 24 Avril 2024",
                    venue: "O2 Universum, Prague",
                    website: "https://www.unrealengine.com/unrealfest",
                    description: "La conf√©rence europ√©enne d√©di√©e √† Unreal Engine.",
                    type: "B2B / Developers",
                    tags: ["UE5", "Tech", "Epic Games"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2024-06-14",
                city: "Hamburg",
                country: "Germany",
                flag: "üá©üá™",
                lat: 53.5511,
                lng: 9.9937,
                color: 0xe74c3c,
                building: "cathedral",
                event: {
                    name: "Gamecamp 2024",
                    fullName: "Gamecamp Hamburg 2024",
                    dates: "14 - 15 Juin 2024",
                    venue: "Hamburg",
                    website: "https://gamecamp.de",
                    description: "Barcamp gaming allemand, format participatif.",
                    type: "B2B / Unconference",
                    tags: ["Indie", "Networking", "Germany"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2024-08-21",
                city: "Cologne",
                country: "Germany",
                flag: "üá©üá™",
                lat: 50.9375,
                lng: 6.9603,
                color: 0xf39c12,
                building: "cathedral",
                event: {
                    name: "Gamescom 2024",
                    fullName: "Gamescom 2024",
                    dates: "21 - 25 Ao√ªt 2024",
                    venue: "Koelnmesse, Cologne",
                    website: "https://www.gamescom.global",
                    description: "Le plus grand salon gaming au monde !",
                    type: "Public & B2B",
                    tags: ["AAA", "Indie", "Business", "Networking"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2024-10-01",
                city: "Seattle",
                country: "USA",
                flag: "üá∫üá∏",
                lat: 47.6062,
                lng: -122.3321,
                color: 0x3498db,
                building: "default",
                event: {
                    name: "Unreal Fest Seattle 2024",
                    fullName: "Unreal Fest Seattle 2024",
                    dates: "1 - 3 Octobre 2024",
                    venue: "Seattle Convention Center",
                    website: "https://www.unrealengine.com/unrealfest",
                    description: "Le flagship Unreal Fest am√©ricain.",
                    type: "B2B / Developers",
                    tags: ["UE5", "Tech", "Epic Games", "USA"],
                    memories: "",
                    highlights: []
                }
            },
            
            // ========== 2025 ==========
            {
                date: "2025-03-17",
                city: "San Francisco",
                country: "USA",
                flag: "üá∫üá∏",
                lat: 37.7749,
                lng: -122.4194,
                color: 0x4facfe,
                building: "goldengate",
                event: {
                    name: "GDC 2025",
                    fullName: "Game Developers Conference 2025",
                    dates: "17 - 21 Mars 2025",
                    venue: "Moscone Center, San Francisco",
                    website: "https://gdconf.com",
                    description: "Retour √† la GDC pour une nouvelle √©dition !",
                    type: "B2B / Developers",
                    tags: ["Dev", "Networking", "UE5", "Business"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2025-07-08",
                city: "Brighton",
                country: "UK",
                flag: "üá¨üáß",
                lat: 50.8225,
                lng: -0.1372,
                color: 0x1abc9c,
                building: "bigben",
                event: {
                    name: "Develop Brighton 2025",
                    fullName: "Develop:Brighton 2025",
                    dates: "8 - 10 Juillet 2025",
                    venue: "Brighton Centre",
                    website: "https://www.developconference.com",
                    description: "La conf√©rence dev gaming majeure au UK.",
                    type: "B2B / Developers",
                    tags: ["UK", "Dev", "Indie", "Networking"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2025-08-20",
                city: "Cologne",
                country: "Germany",
                flag: "üá©üá™",
                lat: 50.9375,
                lng: 6.9603,
                color: 0xf39c12,
                building: "cathedral",
                event: {
                    name: "Gamescom 2025",
                    fullName: "Gamescom 2025",
                    dates: "20 - 24 Ao√ªt 2025",
                    venue: "Koelnmesse, Cologne",
                    website: "https://www.gamescom.global",
                    description: "Retour √† Cologne pour la Gamescom !",
                    type: "Public & B2B",
                    tags: ["AAA", "Indie", "Business", "Networking"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2025-10-08",
                city: "Bali",
                country: "Indonesia",
                flag: "üáÆüá©",
                lat: -8.3405,
                lng: 115.0920,
                color: 0x2ecc71,
                building: "temple",
                event: {
                    name: "IGDX 2025",
                    fullName: "Indonesia Game Developer Exchange 2025",
                    dates: "8 - 10 Octobre 2025",
                    venue: "Bali, Indonesia",
                    website: "https://igdx.id",
                    description: "Conf√©rence B2B gaming en Asie du Sud-Est.",
                    type: "B2B",
                    tags: ["SEA", "Indie", "Mobile", "Networking"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2025-10-16",
                city: "Bangkok",
                country: "Thailand",
                flag: "üáπüá≠",
                lat: 13.7563,
                lng: 100.5018,
                color: 0xe91e63,
                building: "torii",
                event: {
                    name: "Gamescom Asia 2025",
                    fullName: "Gamescom Asia 2025",
                    dates: "16 - 18 Octobre 2025",
                    venue: "Queen Sirikit National Convention Center, Bangkok",
                    website: "https://www.gamescom.asia",
                    description: "La version asiatique de Gamescom !",
                    type: "Public & B2B",
                    tags: ["Asia", "AAA", "Indie", "SEA"],
                    memories: "",
                    highlights: []
                }
            },
            
            // ========== 2026 - √Ä VENIR ==========
            {
                date: "2026-01-19",
                city: "London",
                country: "UK",
                flag: "üá¨üáß",
                lat: 51.5074,
                lng: -0.1278,
                color: 0xff6b6b,
                building: "bigben",
                event: {
                    name: "PG Connects London 2026",
                    fullName: "Pocket Gamer Connects London 2026",
                    dates: "19 - 20 Janvier 2026",
                    venue: "ExCeL London",
                    website: "https://www.pgconnects.com/london",
                    description: "üîú √Ä VENIR - Conf√©rence B2B mobile gaming.",
                    type: "B2B",
                    tags: ["Mobile", "Networking", "Publishers", "UK"],
                    memories: "",
                    highlights: []
                }
            },
            {
                date: "2026-04-15",
                city: "Dubrovnik",
                country: "Croatia",
                flag: "üá≠üá∑",
                lat: 42.6507,
                lng: 18.0944,
                color: 0x00bcd4,
                building: "default",
                event: {
                    name: "Reboot Develop Blue 2026",
                    fullName: "Reboot Develop Blue 2026",
                    dates: "Avril 2026",
                    venue: "Dubrovnik, Croatia",
                    website: "https://rebootdevelopblue.com",
                    description: "üîú √Ä VENIR - La conf dev dans le d√©cor de Game of Thrones !",
                    type: "B2B / Developers",
                    tags: ["Dev", "Indie", "Networking", "Croatia"],
                    memories: "",
                    highlights: []
                }
            },
            
        ];

        // ============================================================
        // üöÄ TRAITEMENT AUTOMATIQUE (ne pas modifier)
        // ============================================================
        
        // Trier les √©v√©nements par date
        MY_EVENTS.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Convertir en format interne
        const cities = MY_EVENTS.map((evt, index) => ({
            name: evt.city,
            flag: evt.flag,
            event: evt.event.name,
            lat: evt.lat,
            lng: evt.lng,
            color: evt.color,
            building: evt.building,
            date: evt.date,
            eventDetails: {
                fullName: evt.event.fullName,
                dates: evt.event.dates,
                venue: evt.event.venue,
                website: evt.event.website,
                description: evt.event.description,
                type: evt.event.type,
                tags: evt.event.tags,
                memories: evt.event.memories || "",
                highlights: evt.event.highlights || []
            },
            // Tous les events pass√©s sont "d√©bloqu√©s"
            isVisited: true,
            index: index
        }));
        
        // Nombre total d'events
        const totalEvents = cities.length;

        // ============ THREE.JS VARIABLES ============
        let scene, camera, renderer, globeGroup;
        let cityMarkers = [];
        let character;
        let mixer; // Pour les animations du mod√®le
        let targetRotation = { x: 0.3, y: 0 };
        let currentRotation = { x: 0.3, y: 0 };
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let currentCityIndex = 0;
        let time = 0;
        let clock = new THREE.Clock();
        let starsObject = null;
        let cityLabels = [];

        // ============ DYNAMIC SETTINGS ============
        let settings = {
            markerScale: 1.0,
            rotationSpeed: 1.0,
            zoomLevel: 1.0,
            starsBrightness: 1.0,
            autoRotate: true,
            showLabels: true
        };

        // ============ CONTROL PANEL FUNCTIONS ============
        function toggleControlPanel() {
            document.getElementById('controlPanel').classList.toggle('collapsed');
        }

        function updateMarkerSize(value) {
            settings.markerScale = value / 100;
            document.getElementById('markerSizeValue').textContent = value + '%';
        }

        function updateRotationSpeed(value) {
            settings.rotationSpeed = value / 100;
            document.getElementById('rotationSpeedValue').textContent = value + '%';
        }

        function updateZoom(value) {
            settings.zoomLevel = value / 100;
            document.getElementById('zoomValue').textContent = value + '%';
            camera.position.z = 4 / settings.zoomLevel;
        }

        function updateStars(value) {
            settings.starsBrightness = value / 100;
            document.getElementById('starsValue').textContent = value + '%';
            if (starsObject) {
                starsObject.material.opacity = 0.8 * settings.starsBrightness;
            }
        }

        function toggleAutoRotate(checked) {
            settings.autoRotate = checked;
        }

        function toggleLabels(checked) {
            settings.showLabels = checked;
            cityLabels.forEach(function(label) {
                label.visible = checked;
            });
        }

        function pickRandom() {
            // Animation du bouton
            var btn = event.target.closest('.control-button');
            btn.style.transform = 'scale(0.95)';
            setTimeout(function() {
                btn.style.transform = '';
            }, 150);

            // S√©lectionner une ville random (pas Worldwide)
            var availableCities = cities.slice(0, -1); // Exclure "Worldwide"
            var randomIndex = Math.floor(Math.random() * availableCities.length);
            
            // Faire tourner le globe vers cette ville
            var city = cities[randomIndex];
            var targetLng = -(city.lng + CONFIG.longitudeOffset) * (Math.PI / 180) - Math.PI/2;
            
            // Animation de rotation vers la ville
            var startY = targetRotation.y;
            var diff = targetLng - startY;
            
            // Normaliser la diff√©rence pour prendre le chemin le plus court
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            
            var duration = 1000;
            var startTime = performance.now();
            
            function animateToCity(currentTime) {
                var progress = Math.min((currentTime - startTime) / duration, 1);
                var eased = 1 - Math.pow(1 - progress, 3); // ease-out
                targetRotation.y = startY + diff * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateToCity);
                } else {
                    // Ouvrir la modal apr√®s l'animation
                    setTimeout(function() {
                        // Calculer la position du marqueur sur l'√©cran
                        var marker = cityMarkers[randomIndex];
                        if (marker) {
                            var vector = new THREE.Vector3();
                            marker.getWorldPosition(vector);
                            vector.project(camera);
                            var x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                            var y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                            openModal(randomIndex, x, y);
                        } else {
                            openModal(randomIndex, window.innerWidth / 2, window.innerHeight / 2);
                        }
                    }, 200);
                }
            }
            
            requestAnimationFrame(animateToCity);
        }

        // ============ INIT ============
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            globeGroup = new THREE.Group();
            scene.add(globeGroup);

            createGlobe();
            createCityMarkers();
            createRoute();
            loadCharacterModel();
            createStars();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);

            const backLight = new THREE.DirectionalLight(0x4facfe, 0.4);
            backLight.position.set(-5, -3, -5);
            scene.add(backLight);

            // Events
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseLeave);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseLeave);
            renderer.domElement.addEventListener('click', onCanvasClick);

            initTimeline();
            animate();
        }

        // ============ MODAL FUNCTIONS ============
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();
        var clickStart = { x: 0, y: 0 };

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            clickStart = { x: e.clientX, y: e.clientY };
        }

        function onCanvasClick(e) {
            // Ne pas ouvrir la modal si on a dragu√©
            var dragDistance = Math.sqrt(
                Math.pow(e.clientX - clickStart.x, 2) + 
                Math.pow(e.clientY - clickStart.y, 2)
            );
            if (dragDistance > 10) return;

            // Raycasting pour d√©tecter le clic sur un marqueur
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            var allMarkerObjects = [];
            cityMarkers.forEach(function(marker) {
                marker.traverse(function(child) {
                    if (child.isMesh) {
                        child.userData.parentMarker = marker;
                        allMarkerObjects.push(child);
                    }
                });
            });

            var intersects = raycaster.intersectObjects(allMarkerObjects);
            
            if (intersects.length > 0) {
                var clickedMarker = intersects[0].object.userData.parentMarker;
                if (clickedMarker && clickedMarker.userData.cityIndex !== undefined) {
                    openModal(clickedMarker.userData.cityIndex, e.clientX, e.clientY);
                }
            }
        }

        function openModal(cityIndex, clickX, clickY) {
            var city = cities[cityIndex];
            var modalInner = document.getElementById('modalInner');
            var modalContent = document.querySelector('.modal-content');
            var modalOverlay = document.getElementById('eventModal');
            
            // Position de d√©part (depuis le clic)
            if (clickX !== undefined && clickY !== undefined) {
                modalContent.style.left = clickX + 'px';
                modalContent.style.top = clickY + 'px';
                modalContent.style.transform = 'translate(-50%, -50%) scale(0.3)';
            } else {
                // Fallback au centre
                modalContent.style.left = '50%';
                modalContent.style.top = '50%';
                modalContent.style.transform = 'translate(-50%, -50%) scale(0.3)';
            }
            
            var details = city.eventDetails;
            var tagsHTML = details.tags.map(function(tag) {
                return '<span class="modal-tag">' + tag + '</span>';
            }).join('');
            
            var websiteHTML = details.website ? 
                '<a href="' + details.website + '" target="_blank" class="modal-website">üåê Visiter le site officiel</a>' : '';

            // Souvenirs personnels (optionnel)
            var memoriesHTML = details.memories ? 
                '<div class="modal-row">' +
                    '<span class="modal-icon">üí≠</span>' +
                    '<div>' +
                        '<div class="modal-label">Mes souvenirs</div>' +
                        '<div class="modal-value modal-description">' + details.memories + '</div>' +
                    '</div>' +
                '</div>' : '';

            // Highlights (optionnel)
            var highlightsHTML = '';
            if (details.highlights && details.highlights.length > 0) {
                var highlightsList = details.highlights.map(function(h) {
                    return '<li>' + h + '</li>';
                }).join('');
                highlightsHTML = 
                    '<div class="modal-row">' +
                        '<span class="modal-icon">‚≠ê</span>' +
                        '<div>' +
                            '<div class="modal-label">Points forts</div>' +
                            '<ul class="modal-highlights">' + highlightsList + '</ul>' +
                        '</div>' +
                    '</div>';
            }

            // Num√©ro dans la timeline
            var eventNumber = cityIndex + 1;
            var totalEvents = cities.length;

            modalInner.innerHTML = 
                '<div class="modal-header">' +
                    '<div class="modal-event-number">Event #' + eventNumber + '/' + totalEvents + '</div>' +
                    '<div class="modal-flag">' + city.flag + '</div>' +
                    '<div class="modal-title">' + details.fullName + '</div>' +
                    '<div class="modal-dates">üìÖ ' + details.dates + '</div>' +
                '</div>' +
                '<div class="modal-body">' +
                    '<div class="modal-row">' +
                        '<span class="modal-icon">üìç</span>' +
                        '<div>' +
                            '<div class="modal-label">Lieu</div>' +
                            '<div class="modal-value">' + details.venue + '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="modal-row">' +
                        '<span class="modal-icon">üé´</span>' +
                        '<div>' +
                            '<div class="modal-label">Type</div>' +
                            '<div class="modal-value">' + details.type + '</div>' +
                        '</div>' +
                    '</div>' +
                    '<div class="modal-row">' +
                        '<span class="modal-icon">üìù</span>' +
                        '<div>' +
                            '<div class="modal-label">Description</div>' +
                            '<div class="modal-value modal-description">' + details.description + '</div>' +
                        '</div>' +
                    '</div>' +
                    memoriesHTML +
                    highlightsHTML +
                    '<div class="modal-row">' +
                        '<span class="modal-icon">üè∑Ô∏è</span>' +
                        '<div>' +
                            '<div class="modal-label">Tags</div>' +
                            '<div class="modal-tags">' + tagsHTML + '</div>' +
                        '</div>' +
                    '</div>' +
                    websiteHTML +
                '</div>';

            // D√©clencher l'animation apr√®s un petit d√©lai
            requestAnimationFrame(function() {
                modalOverlay.classList.add('active');
            });
        }

        function closeModal(e) {
            if (e && e.target !== e.currentTarget) return;
            var modalOverlay = document.getElementById('eventModal');
            var modalContent = document.querySelector('.modal-content');
            
            // Animation de fermeture
            modalContent.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
            modalOverlay.classList.remove('active');
            
            // Reset transition apr√®s fermeture
            setTimeout(function() {
                modalContent.style.transition = 'opacity 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
            }, 300);
        }

        // Fermer avec Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeModal();
        });

        // ============ GLOBE AVEC TEXTURE ============
        function createGlobe() {
            const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
            
            // Cr√©er d'abord un globe basique (visible imm√©diatement)
            const basicMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a4a7a,
                emissive: 0x0a1a2a,
                emissiveIntensity: 0.3,
                shininess: 10
            });
            const globe = new THREE.Mesh(globeGeometry, basicMaterial);
            globe.name = 'earth';
            globeGroup.add(globe);
            
            // Ajouter des continents simplifi√©s
            createFallbackContinents();
            
            // Puis essayer de charger la texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                CONFIG.earthTexture,
                function(texture) {
                    console.log('‚úÖ Texture Terre charg√©e !');
                    globe.material = new THREE.MeshPhongMaterial({
                        map: texture,
                        bumpMap: texture,
                        bumpScale: 0.02,
                        specular: new THREE.Color(0x333333),
                        shininess: 5
                    });
                    // Supprimer les continents fallback
                    var continentsToRemove = [];
                    globeGroup.traverse(function(child) {
                        if (child.userData && child.userData.isFallbackContinent) {
                            continentsToRemove.push(child);
                        }
                    });
                    continentsToRemove.forEach(function(c) { globeGroup.remove(c); });
                },
                undefined,
                function(error) {
                    console.log('‚ö†Ô∏è Texture non trouv√©e, garde le style par d√©faut');
                }
            );

            // Wireframe grid
            const wireGeometry = new THREE.SphereGeometry(1.005, 36, 18);
            const wireMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                wireframe: true,
                transparent: true,
                opacity: 0.08
            });
            const wireframe = new THREE.Mesh(wireGeometry, wireMaterial);
            globeGroup.add(wireframe);

            // Atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(1.12, 64, 64);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x4facfe,
                transparent: true,
                opacity: 0.12,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            globeGroup.add(atmosphere);
        }

        // Globe de secours si pas de texture
        function createFallbackGlobe(geometry) {
            // Non utilis√© maintenant, le fallback est int√©gr√© dans createGlobe
        }

        function createFallbackContinents() {
            const continentData = [
                { lat: 50, lng: 10, scale: 0.15 },
                { lat: 45, lng: 0, scale: 0.12 },
                { lat: 55, lng: 20, scale: 0.1 },
                { lat: 35, lng: 100, scale: 0.25 },
                { lat: 50, lng: 80, scale: 0.2 },
                { lat: 25, lng: 120, scale: 0.15 },
                { lat: 40, lng: 140, scale: 0.1 },
                { lat: 45, lng: -100, scale: 0.22 },
                { lat: 35, lng: -90, scale: 0.18 },
                { lat: 55, lng: -110, scale: 0.15 },
                { lat: -15, lng: -60, scale: 0.18 },
                { lat: -30, lng: -65, scale: 0.12 },
                { lat: 10, lng: 20, scale: 0.2 },
                { lat: -10, lng: 25, scale: 0.15 },
                { lat: 25, lng: 30, scale: 0.1 },
                { lat: -25, lng: 135, scale: 0.14 },
                { lat: -5, lng: 115, scale: 0.1 },
            ];

            const landMaterial = new THREE.MeshPhongMaterial({
                color: 0x2d5a3d,
                emissive: 0x1a3320,
                emissiveIntensity: 0.2
            });

            continentData.forEach(function(continent) {
                const pos = latLngToVector3(continent.lat, continent.lng, 1.001);
                const geometry = new THREE.CircleGeometry(continent.scale, 16);
                const mesh = new THREE.Mesh(geometry, landMaterial);
                mesh.position.copy(pos);
                mesh.lookAt(0, 0, 0);
                mesh.rotateX(Math.PI);
                mesh.userData.isFallbackContinent = true;
                globeGroup.add(mesh);
            });
        }

        // ============ HELPERS ============
        function latLngToVector3(lat, lng, radius) {
            radius = radius || 1.02;
            // Appliquer le d√©calage de longitude pour calibration
            var adjustedLng = lng + CONFIG.longitudeOffset;
            var phi = (90 - lat) * (Math.PI / 180);
            var theta = (adjustedLng + 180) * (Math.PI / 180);
            return new THREE.Vector3(
                -radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.cos(phi),
                radius * Math.sin(phi) * Math.sin(theta)
            );
        }

        // ============ CITY MARKERS ============
        function createCityMarkers() {
            cities.forEach(function(city, index) {
                if (city.name === "Worldwide") return;
                
                var position = latLngToVector3(city.lat, city.lng, 1.01);
                var markerGroup = new THREE.Group();
                
                // Positionner le groupe sur le globe
                markerGroup.position.copy(position);
                
                // Orienter le marqueur pour qu'il pointe vers l'ext√©rieur du globe
                var up = position.clone().normalize();
                var quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), up);
                markerGroup.setRotationFromQuaternion(quaternion);

                // === BASE DU PIN (cercle au sol) ===
                var baseRingGeometry = new THREE.RingGeometry(0.012, 0.018, 32);
                var baseRingMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                var baseRing = new THREE.Mesh(baseRingGeometry, baseRingMaterial);
                baseRing.rotation.x = -Math.PI / 2;
                baseRing.position.y = 0.001;
                markerGroup.add(baseRing);

                // === ANNEAU LUMINEUX √Ä LA BASE ===
                var pulseRingGeometry = new THREE.RingGeometry(0.02, 0.03, 32);
                var pulseRingMaterial = new THREE.MeshBasicMaterial({
                    color: city.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.3
                });
                var pulseRing = new THREE.Mesh(pulseRingGeometry, pulseRingMaterial);
                pulseRing.rotation.x = -Math.PI / 2;
                pulseRing.position.y = 0.002;
                pulseRing.userData.isPulseRing = true;
                markerGroup.add(pulseRing);

                // === LABEL 3D ===
                var label = createCityLabel(city.name, city.flag, city.color);
                label.position.y = 0.16;
                markerGroup.add(label);
                cityLabels.push(label);

                // === HITBOX INVISIBLE (pour faciliter le hover) ===
                var hitboxGeometry = new THREE.PlaneGeometry(0.25, 0.20);
                var hitboxMaterial = new THREE.MeshBasicMaterial({
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                var hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
                hitbox.position.y = 0.08;
                hitbox.userData.isHitbox = true;
                markerGroup.add(hitbox);

                // === B√ÇTIMENT 3D CARTOON ===
                var building = createCityBuilding(city.building || 'default', city.color);
                building.position.y = 0.0;
                markerGroup.add(building);

                markerGroup.userData = { cityIndex: index };
                globeGroup.add(markerGroup);
                cityMarkers.push(markerGroup);
            });
        }

        function createCityLabel(name, flag, color) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.moveTo(12, 0);
            ctx.lineTo(244, 0);
            ctx.quadraticCurveTo(256, 0, 256, 12);
            ctx.lineTo(256, 52);
            ctx.quadraticCurveTo(256, 64, 244, 64);
            ctx.lineTo(12, 64);
            ctx.quadraticCurveTo(0, 64, 0, 52);
            ctx.lineTo(0, 12);
            ctx.quadraticCurveTo(0, 0, 12, 0);
            ctx.fill();

            ctx.strokeStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(flag + ' ' + name, canvas.width / 2, canvas.height / 2);

            var texture = new THREE.CanvasTexture(canvas);
            var spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false
            });
            var sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.25, 0.0625, 1);
            
            return sprite;
        }

        // ============ CARTOON BUILDINGS ============
        function createCityBuilding(buildingType, color) {
            var building = new THREE.Group();
            
            switch(buildingType) {
                case "eiffel":
                    building = createEiffelTower(color);
                    break;
                case "cathedral":
                    building = createCathedral(color);
                    break;
                case "bigben":
                    building = createBigBen(color);
                    break;
                case "goldengate":
                    building = createGoldenGate(color);
                    break;
                case "hollywood":
                    building = createHollywood(color);
                    break;
                case "torii":
                    building = createTorii(color);
                    break;
                case "temple":
                    building = createBaliTemple(color);
                    break;
                default:
                    building = createDefaultBuilding(color);
            }
            
            return building;
        }

        function createEiffelTower(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0x8b7355, emissive: 0x2a2015, emissiveIntensity: 0.3 });
            
            // Base (4 pieds)
            for (var i = 0; i < 4; i++) {
                var angle = (i / 4) * Math.PI * 2 + Math.PI / 4;
                var legGeom = new THREE.CylinderGeometry(0.003, 0.008, 0.04, 6);
                var leg = new THREE.Mesh(legGeom, material);
                leg.position.set(Math.cos(angle) * 0.015, 0.02, Math.sin(angle) * 0.015);
                leg.rotation.z = Math.cos(angle) * 0.3;
                leg.rotation.x = Math.sin(angle) * 0.3;
                group.add(leg);
            }
            
            // Corps central
            var bodyGeom = new THREE.CylinderGeometry(0.002, 0.012, 0.05, 4);
            var body = new THREE.Mesh(bodyGeom, material);
            body.position.y = 0.045;
            group.add(body);
            
            // Sommet
            var topGeom = new THREE.CylinderGeometry(0.001, 0.003, 0.025, 4);
            var top = new THREE.Mesh(topGeom, material);
            top.position.y = 0.08;
            group.add(top);
            
            // Antenne
            var antennaGeom = new THREE.CylinderGeometry(0.001, 0.001, 0.015, 4);
            var antenna = new THREE.Mesh(antennaGeom, material);
            antenna.position.y = 0.10;
            group.add(antenna);
            
            // Lumi√®re au sommet
            var lightGeom = new THREE.SphereGeometry(0.003, 8, 8);
            var lightMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            var light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 0.11;
            group.add(light);
            
            return group;
        }

        function createCathedral(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0x888888, emissive: 0x222222, emissiveIntensity: 0.2 });
            
            // Corps principal
            var bodyGeom = new THREE.BoxGeometry(0.03, 0.04, 0.02);
            var body = new THREE.Mesh(bodyGeom, material);
            body.position.y = 0.02;
            group.add(body);
            
            // Deux tours
            for (var i = -1; i <= 1; i += 2) {
                var towerGeom = new THREE.BoxGeometry(0.012, 0.06, 0.012);
                var tower = new THREE.Mesh(towerGeom, material);
                tower.position.set(i * 0.012, 0.03, 0);
                group.add(tower);
                
                // Fl√®che
                var spireGeom = new THREE.ConeGeometry(0.008, 0.025, 4);
                var spire = new THREE.Mesh(spireGeom, material);
                spire.position.set(i * 0.012, 0.07, 0);
                group.add(spire);
            }
            
            return group;
        }

        function createBigBen(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0xc9a86c, emissive: 0x3a3020, emissiveIntensity: 0.2 });
            
            // Tour principale
            var towerGeom = new THREE.BoxGeometry(0.02, 0.07, 0.02);
            var tower = new THREE.Mesh(towerGeom, material);
            tower.position.y = 0.035;
            group.add(tower);
            
            // Horloge (face)
            var clockGeom = new THREE.CircleGeometry(0.008, 16);
            var clockMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            var clock = new THREE.Mesh(clockGeom, clockMat);
            clock.position.set(0, 0.05, 0.011);
            group.add(clock);
            
            // Toit
            var roofGeom = new THREE.ConeGeometry(0.015, 0.025, 4);
            var roof = new THREE.Mesh(roofGeom, material);
            roof.position.y = 0.08;
            roof.rotation.y = Math.PI / 4;
            group.add(roof);
            
            // Fl√®che dor√©e
            var spireGeom = new THREE.ConeGeometry(0.003, 0.015, 4);
            var spireMat = new THREE.MeshPhongMaterial({ color: 0xffd700 });
            var spire = new THREE.Mesh(spireGeom, spireMat);
            spire.position.y = 0.10;
            group.add(spire);
            
            return group;
        }

        function createGoldenGate(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0xc13a28, emissive: 0x3a1010, emissiveIntensity: 0.3 });
            
            // Deux pyl√¥nes
            for (var i = -1; i <= 1; i += 2) {
                var pylonGeom = new THREE.BoxGeometry(0.008, 0.07, 0.008);
                var pylon = new THREE.Mesh(pylonGeom, material);
                pylon.position.set(i * 0.025, 0.035, 0);
                group.add(pylon);
            }
            
            // C√¢ble sup√©rieur
            var cableGeom = new THREE.CylinderGeometry(0.002, 0.002, 0.06, 8);
            var cable = new THREE.Mesh(cableGeom, material);
            cable.position.y = 0.065;
            cable.rotation.z = Math.PI / 2;
            group.add(cable);
            
            // Route
            var roadGeom = new THREE.BoxGeometry(0.07, 0.005, 0.015);
            var roadMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            var road = new THREE.Mesh(roadGeom, roadMat);
            road.position.y = 0.01;
            group.add(road);
            
            return group;
        }

        function createHollywood(color) {
            var group = new THREE.Group();
            
            // Palmier
            var trunkMat = new THREE.MeshPhongMaterial({ color: 0x8b6914 });
            var trunkGeom = new THREE.CylinderGeometry(0.004, 0.006, 0.05, 8);
            var trunk = new THREE.Mesh(trunkGeom, trunkMat);
            trunk.position.set(-0.02, 0.025, 0);
            group.add(trunk);
            
            // Feuilles
            var leafMat = new THREE.MeshPhongMaterial({ color: 0x228b22, side: THREE.DoubleSide });
            for (var i = 0; i < 6; i++) {
                var angle = (i / 6) * Math.PI * 2;
                var leafGeom = new THREE.ConeGeometry(0.008, 0.025, 4);
                var leaf = new THREE.Mesh(leafGeom, leafMat);
                leaf.position.set(-0.02 + Math.cos(angle) * 0.01, 0.055, Math.sin(angle) * 0.01);
                leaf.rotation.z = Math.cos(angle) * 0.8;
                leaf.rotation.x = Math.sin(angle) * 0.8;
                group.add(leaf);
            }
            
            // √âtoile
            var starMat = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
            var starGeom = new THREE.OctahedronGeometry(0.012, 0);
            var star = new THREE.Mesh(starGeom, starMat);
            star.position.set(0.02, 0.03, 0);
            star.rotation.z = Math.PI / 4;
            group.add(star);
            
            return group;
        }

        function createTorii(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0xd62728, emissive: 0x4a0a0a, emissiveIntensity: 0.3 });
            
            // Deux piliers
            for (var i = -1; i <= 1; i += 2) {
                var pillarGeom = new THREE.CylinderGeometry(0.004, 0.005, 0.06, 8);
                var pillar = new THREE.Mesh(pillarGeom, material);
                pillar.position.set(i * 0.02, 0.03, 0);
                group.add(pillar);
            }
            
            // Barre sup√©rieure (kasagi)
            var topBarGeom = new THREE.BoxGeometry(0.06, 0.006, 0.008);
            var topBar = new THREE.Mesh(topBarGeom, material);
            topBar.position.y = 0.06;
            group.add(topBar);
            
            // Barre interm√©diaire
            var midBarGeom = new THREE.BoxGeometry(0.05, 0.004, 0.006);
            var midBar = new THREE.Mesh(midBarGeom, material);
            midBar.position.y = 0.045;
            group.add(midBar);
            
            return group;
        }

        function createBaliTemple(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: 0x8b7355, emissive: 0x2a2015, emissiveIntensity: 0.2 });
            
            // Base
            var baseGeom = new THREE.BoxGeometry(0.03, 0.01, 0.03);
            var base = new THREE.Mesh(baseGeom, material);
            base.position.y = 0.005;
            group.add(base);
            
            // Niveaux du temple (style Meru)
            var levels = 5;
            for (var i = 0; i < levels; i++) {
                var size = 0.025 - i * 0.004;
                var levelGeom = new THREE.ConeGeometry(size, 0.012, 4);
                var level = new THREE.Mesh(levelGeom, material);
                level.position.y = 0.015 + i * 0.012;
                level.rotation.y = Math.PI / 4;
                group.add(level);
            }
            
            // Sommet dor√©
            var topGeom = new THREE.SphereGeometry(0.004, 8, 8);
            var topMat = new THREE.MeshPhongMaterial({ color: 0xffd700 });
            var top = new THREE.Mesh(topGeom, topMat);
            top.position.y = 0.075;
            group.add(top);
            
            return group;
        }

        function createDefaultBuilding(color) {
            var group = new THREE.Group();
            var material = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.2 });
            
            var buildingGeom = new THREE.BoxGeometry(0.02, 0.04, 0.02);
            var building = new THREE.Mesh(buildingGeom, material);
            building.position.y = 0.02;
            group.add(building);
            
            return group;
        }

        // ============ ROUTE ============
        function createRoute() {
            var points = [];
            
            for (var i = 0; i < cities.length - 1; i++) {
                var start = latLngToVector3(cities[i].lat, cities[i].lng, 1.03);
                var end = latLngToVector3(cities[i + 1].lat, cities[i + 1].lng, 1.03);
                var arcPoints = createArc(start, end, 30);
                points = points.concat(arcPoints);
            }

            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            var material = new THREE.LineBasicMaterial({
                color: 0xf093fb,
                transparent: true,
                opacity: 0.7
            });
            var route = new THREE.Line(geometry, material);
            globeGroup.add(route);
        }

        function createArc(start, end, segments) {
            var points = [];
            for (var i = 0; i <= segments; i++) {
                var t = i / segments;
                var point = new THREE.Vector3().lerpVectors(start, end, t);
                var elevation = Math.sin(t * Math.PI) * 0.1;
                point.normalize().multiplyScalar(1.03 + elevation);
                points.push(point);
            }
            return points;
        }

        // ============ CHARGER MODELE 3D DU PERSONNAGE ============
        function loadCharacterModel() {
            var loader = new THREE.GLTFLoader();
            
            loader.load(
                CONFIG.characterModel,
                // Succ√®s
                function(gltf) {
                    console.log('‚úÖ Mod√®le personnage charg√© !');
                    character = gltf.scene;
                    character.scale.setScalar(CONFIG.characterScale);
                    
                    // Appliquer rotation si configur√©e
                    character.rotation.x = CONFIG.characterRotation.x;
                    character.rotation.y = CONFIG.characterRotation.y;
                    character.rotation.z = CONFIG.characterRotation.z;
                    
                    // Charger les animations si pr√©sentes
                    if (gltf.animations && gltf.animations.length > 0) {
                        mixer = new THREE.AnimationMixer(character);
                        var action = mixer.clipAction(gltf.animations[0]);
                        action.play();
                        console.log('‚úÖ Animation charg√©e !');
                    }
                    
                    globeGroup.add(character);
                    updateCharacterPosition(0);
                    updateUI();
                },
                // Progression
                function(xhr) {
                    console.log('Chargement mod√®le: ' + (xhr.loaded / xhr.total * 100) + '%');
                },
                // Erreur : cr√©er un personnage par d√©faut
                function(error) {
                    console.log('‚ö†Ô∏è Mod√®le non trouv√©, utilisation du personnage par d√©faut');
                    createFallbackCharacter();
                }
            );
        }

        // Personnage de secours si pas de mod√®le GLB
        function createFallbackCharacter() {
            character = new THREE.Group();

            var skinMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac, emissive: 0x331100, emissiveIntensity: 0.1 });

            // === BIG HEAD ===
            var headGeometry = new THREE.SphereGeometry(0.055, 32, 32);
            var head = new THREE.Mesh(headGeometry, skinMaterial);
            head.position.y = 0.08;
            character.add(head);

            // Hair
            var hairGeometry = new THREE.SphereGeometry(0.058, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
            var hairMaterial = new THREE.MeshPhongMaterial({ color: 0x3a2718 });
            var hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 0.085;
            hair.rotation.x = -0.15;
            character.add(hair);

            // Eyes
            var eyeGeometry = new THREE.SphereGeometry(0.012, 16, 16);
            var eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            
            var leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.02, 0.085, 0.045);
            character.add(leftEye);

            var rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.02, 0.085, 0.045);
            character.add(rightEye);

            // Eye highlights
            var highlightGeometry = new THREE.SphereGeometry(0.005, 8, 8);
            var highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            var leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            leftHighlight.position.set(-0.016, 0.09, 0.055);
            character.add(leftHighlight);

            var rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
            rightHighlight.position.set(0.024, 0.09, 0.055);
            character.add(rightHighlight);

            // === BODY ===
            var bodyGeometry = new THREE.CylinderGeometry(0.025, 0.028, 0.045, 16);
            var bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4facfe, emissive: 0x1a3a5c, emissiveIntensity: 0.3 });
            var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.01;
            character.add(body);

            // === BACKPACK ===
            var backpackGeometry = new THREE.BoxGeometry(0.03, 0.04, 0.02);
            var backpackMaterial = new THREE.MeshPhongMaterial({ color: 0xf093fb, emissive: 0x5a2060, emissiveIntensity: 0.3 });
            var backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.015, -0.035);
            character.add(backpack);

            // === LEGS ===
            var legGeometry = new THREE.CylinderGeometry(0.01, 0.012, 0.03, 8);
            var legMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.015, -0.035, 0);
            character.add(leftLeg);

            var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.015, -0.035, 0);
            character.add(rightLeg);

            // === CAP ===
            var capGeometry = new THREE.SphereGeometry(0.048, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            var capMaterial = new THREE.MeshPhongMaterial({ color: 0xff4757, emissive: 0x5a1a1a, emissiveIntensity: 0.2 });
            var cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 0.115;
            cap.rotation.x = -0.1;
            character.add(cap);

            globeGroup.add(character);
            updateCharacterPosition(0);
        }

        function updateCharacterPosition(progress) {
            if (!character) return;
            
            var totalCities = cities.length - 1;
            var cityProgress = progress * totalCities;
            var currentIdx = Math.min(Math.floor(cityProgress), totalCities - 1);
            var nextIdx = Math.min(currentIdx + 1, totalCities);
            var localProgress = cityProgress - currentIdx;

            var startPos = latLngToVector3(cities[currentIdx].lat, cities[currentIdx].lng, 1.15);
            var endPos = latLngToVector3(cities[nextIdx].lat, cities[nextIdx].lng, 1.15);

            character.position.lerpVectors(startPos, endPos, localProgress);
            
            var arcHeight = Math.sin(localProgress * Math.PI) * 0.04;
            character.position.normalize().multiplyScalar(1.15 + arcHeight);
            
            character.lookAt(0, 0, 0);
            character.rotateX(Math.PI / 2);
        }

        // ============ STARS ============
        function createStars() {
            var starsGeometry = new THREE.BufferGeometry();
            var starsVertices = [];
            for (var i = 0; i < 2000; i++) {
                starsVertices.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            var starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.8 });
            starsObject = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starsObject);
        }

        // ============ CONTROLS ============
        function onMouseMove(e) {
            // Raycasting pour d√©tecter le survol des marqueurs
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            // Collecter tous les objets des marqueurs (incluant les hitbox)
            var allMarkerObjects = [];
            cityMarkers.forEach(function(marker) {
                marker.traverse(function(child) {
                    if (child.isMesh) {
                        child.userData.parentMarker = marker;
                        allMarkerObjects.push(child);
                    }
                });
            });
            
            var intersects = raycaster.intersectObjects(allMarkerObjects);
            var tooltip = document.getElementById('hoverTooltip');
            
            // Reset tous les marqueurs
            cityMarkers.forEach(function(marker) {
                marker.userData.isHovered = false;
            });
            
            if (intersects.length > 0) {
                // Trouver le marqueur parent via userData
                var hoveredMarker = intersects[0].object.userData.parentMarker;
                var hoveredCityIndex = -1;
                
                if (hoveredMarker) {
                    hoveredMarker.userData.isHovered = true;
                    hoveredCityIndex = hoveredMarker.userData.cityIndex;
                }
                
                // Afficher le tooltip
                if (hoveredCityIndex >= 0) {
                    var city = cities[hoveredCityIndex];
                    var dateStr = new Date(city.date).toLocaleDateString('fr-FR', { month: 'short', year: 'numeric' });
                    
                    document.getElementById('tooltipFlag').textContent = city.flag;
                    document.getElementById('tooltipName').textContent = city.name;
                    document.getElementById('tooltipEvent').textContent = city.event + ' ‚Ä¢ ' + dateStr;
                    
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY - 10) + 'px';
                    tooltip.classList.add('visible');
                }
                
                renderer.domElement.style.cursor = 'pointer';
            } else {
                tooltip.classList.remove('visible');
                renderer.domElement.style.cursor = isDragging ? 'grabbing' : 'grab';
            }
            
            if (!isDragging) return;
            targetRotation.y += (e.clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseUp() { 
            isDragging = false;
            document.getElementById('hoverTooltip').classList.remove('visible');
        }

        function onMouseLeave() {
            isDragging = false;
            document.getElementById('hoverTooltip').classList.remove('visible');
            cityMarkers.forEach(function(marker) {
                marker.userData.isHovered = false;
            });
        }

        function onMouseWheel(e) {
            camera.position.z = Math.max(2, Math.min(6, camera.position.z + e.deltaY * 0.002));
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }

        function onTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            targetRotation.y += (e.touches[0].clientX - previousMousePosition.x) * 0.005;
            targetRotation.x += (e.touches[0].clientY - previousMousePosition.y) * 0.005;
            targetRotation.x = Math.max(-1, Math.min(1, targetRotation.x));
            previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ TIMELINE INIT ============
        function initTimeline() {
            // Le personnage est sur le dernier event
            currentCityIndex = Math.max(0, cities.length - 1);
            updateUI();
        }

        function updateUI() {
            // Afficher le nombre d'events
            animateNumber(document.getElementById('visitorCount'), 0, cities.length, 1500);

            var currentCity = cities[currentCityIndex];
            var isFirst = currentCityIndex === 0;
            var isLast = currentCityIndex === cities.length - 1;

            // Carte du bas
            document.getElementById('locationFlag').textContent = currentCity.flag;
            document.getElementById('locationCity').textContent = currentCity.name;
            document.getElementById('locationEvent').textContent = currentCity.event;
            
            // Afficher la date au lieu du message de d√©blocage
            var dateFormatted = new Date(currentCity.date).toLocaleDateString('fr-FR', { 
                month: 'long', 
                year: 'numeric' 
            });
            document.getElementById('locationUnlock').innerHTML = '<span>üìÖ</span><span>' + dateFormatted + '</span>';

            // Progress bar (bas√©e sur le nombre d'events)
            var progress = ((currentCityIndex + 1) / cities.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressCurrent').textContent = 'Event ' + (currentCityIndex + 1) + '/' + cities.length;
            document.getElementById('progressNext').textContent = 
                isLast ? 'üèÜ Dernier event !' : 'Next: ' + cities[currentCityIndex + 1].name;

            // L√©gende
            var legendHTML = '';
            cities.forEach(function(city, index) {
                var visitedClass = 'unlocked'; // Tous les events sont visit√©s
                var currentClass = index === currentCityIndex ? 'current' : '';
                var dateStr = new Date(city.date).toLocaleDateString('fr-FR', { month: 'short', year: '2-digit' });
                legendHTML += '<div class="legend-item ' + visitedClass + ' ' + currentClass + '" onclick="openModal(' + index + ', event.clientX, event.clientY)">' +
                    '<span class="legend-dot"></span>' +
                    '<span>' + city.flag + ' ' + city.name + ' <small style="opacity:0.5">(' + dateStr + ')</small></span>' +
                    '</div>';
            });
            document.getElementById('legendItems').innerHTML = legendHTML;

            // Position du personnage (sur le dernier event)
            if (cities.length > 0) {
                updateCharacterPosition(currentCityIndex / Math.max(cities.length - 1, 1));
            }
        }

        function animateNumber(el, start, end, duration) {
            var startTime = performance.now();
            function update(currentTime) {
                var progress = Math.min((currentTime - startTime) / duration, 1);
                el.textContent = Math.floor(start + (end - start) * (1 - Math.pow(1 - progress, 3))).toLocaleString();
                if (progress < 1) requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        // ============ ANIMATION LOOP ============
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            var delta = clock.getDelta();

            // Update animations du mod√®le
            if (mixer) {
                mixer.update(delta);
            }

            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            globeGroup.rotation.x = currentRotation.x;
            globeGroup.rotation.y = currentRotation.y;

            if (!isDragging && settings.autoRotate) {
                targetRotation.y += 0.001 * settings.rotationSpeed;
            }

            // Character bobbing
            if (character) {
                character.position.y += Math.sin(time * 4) * 0.0002;
            }

            // Pulse current city marker + animate rings + hover effect
            cityMarkers.forEach(function(marker, index) {
                var isCurrent = index === currentCityIndex;
                var isHovered = marker.userData.isHovered;
                
                // Scale du marqueur avec le multiplicateur global + hover boost
                var baseScale = isCurrent ? 1.3 : 1;
                var pulseScale = isCurrent ? Math.sin(time * 3) * 0.1 : 0;
                var hoverBoost = isHovered ? 0.3 : 0;
                marker.scale.setScalar((baseScale + pulseScale + hoverBoost) * settings.markerScale);
                
                // Animation des anneaux pulse + hover glow
                marker.traverse(function(child) {
                    if (child.userData && child.userData.isPulseRing) {
                        if (isHovered) {
                            var hoverPulse = 1 + Math.sin(time * 5) * 0.4;
                            child.scale.set(hoverPulse * 1.5, hoverPulse * 1.5, 1);
                            child.material.opacity = 0.6;
                        } else if (isCurrent) {
                            var pulseRingScale = 1 + Math.sin(time * 2) * 0.3;
                            child.scale.set(pulseRingScale, pulseRingScale, 1);
                            child.material.opacity = 0.4 - Math.sin(time * 2) * 0.2;
                        } else {
                            child.scale.set(1, 1, 1);
                            child.material.opacity = 0.2;
                        }
                    }
                    
                    // Boost emissive au hover
                    if (child.isMesh && child.material && child.material.emissive) {
                        if (isHovered) {
                            child.material.emissiveIntensity = 0.8;
                        } else {
                            child.material.emissiveIntensity = isCurrent ? 0.5 : 0.3;
                        }
                    }
                });
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
